<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<link rel="stylesheet" href="/_assets/main.css" />

    <title>第四周作业 - Alfie Cheung</title>
  <link rel="stylesheet" href="/_markdown_plugin_assets/highlight.js/atom-one-light.css" /></head>
  <body>
    <div class="main">
      <nav class="navigation">
        <a href="/">Alfie Cheung</a>
      </nav>
      <article>
        <header>
          <h1 class="article-title">第四周作业</h1>
          <div class="article-info">
            <div>
              <span
                >Created At：<time datetime="1714262288490"
                  >2024-04-28 07:58</time
                ></span
              >
              <span
                >Updated At：<time datetime="1714262907051"
                  >2024-04-28 08:08</time
                ></span
              >
            </div>
            
          </div>
        </header>
        <div class="article-content markdown-body"><h1 id="dockerfile命令">Dockerfile命令</h1>
<h2 id="from">FROM</h2>
<p>!!!  note 基本信息</p>
<ul>
<li>用途
<ul>
<li>所有的镜像都通过基础镜像而来，该语句指定基础镜像是谁，基于什么镜像来做。</li>
</ul>
</li>
<li>格式
<ul>
<li>
<p>FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]</p>
</li>
<li>
<p>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</p>
</li>
<li>
<p>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</p>
</li>
<li>
<p><code>--platform</code> 指定镜像的平台，比如: <code>linux/amd64</code>, <code>linux/arm64</code>, or <code>windows/amd64</code></p>
</li>
<li>
<p><code>tag</code> 和 <code>digest</code>是可选项，如果不指定，默认为<code>latest</code><br />
!!!</p>
</li>
</ul>
</li>
</ul>
<p>!!! tip 常见用法</p>
<ol>
<li>
<p>完全自建镜像，需要空镜像<br />
FROM scratch</p>
<blockquote>
<p>scratch是一切镜像的起源，它本身无具体的操作系统，可以理解为一个占位符<br />
它本质上是一个 0 字节的镜像<br />
对于静态编译中，多阶段编译有奇效</p>
</blockquote>
<div><pre class="hljs"><code><span class="hljs-comment"># 使用 golang 基础镜像进行构建</span>
<span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.16</span> AS builder

<span class="hljs-comment"># 设置工作目录</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span>

<span class="hljs-comment"># 复制 Go 项目文件到容器中</span>
<span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span>

<span class="hljs-comment"># 静态编译 Go 程序</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o myapp .</span>

<span class="hljs-comment"># 使用 scratch 空白镜像作为最终镜像</span>
<span class="hljs-keyword">FROM</span> scratch

<span class="hljs-comment"># 从构建阶段复制编译好的可执行文件到最终镜像</span>
<span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /app/myapp /</span>

<span class="hljs-comment"># 定义容器启动时执行的命令</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">"/myapp"</span>]</span></code></pre></div>
</li>
<li>
<p>从精简操作系统的基础下构建<br />
FROM busybox / FROM alpine</p>
<blockquote>
<p>精简操作系统一般在 <code>10M</code>之内，这些系统具备最基础的功能能够胜任一般的错误排查<br />
不至于如空白镜像，需要自行对工具进行选型、依赖解决等、可以较好地完成部署任务<br />
是一个性价比极高的基础镜像</p>
</blockquote>
</li>
<li>
<p>从完整操作系统镜像下构建<br />
FROM ubuntu / FROM Rockylinux</p>
<blockquote>
<p>这些一般为主流操作系统，用户最为熟悉，拥有的系统工具丰富，对于故障和配置排查提供了基础<br />
一般具备主流的bash，而不是精简系统的sh<br />
大小一般在<code>100M</code>到<code>500M</code>之间</p>
</blockquote>
</li>
<li>
<p>从应用镜像构建<br />
FROM redis / FROM jenkins</p>
<blockquote>
<p>这类镜像已经是完整的应用，其空间大小与应用和其选择的系统基座相关<br />
从这一类镜像进行构建，一般是为了实现告警的自定义功能或精简配置<br />
!!!</p>
</blockquote>
</li>
</ol>
<p>!!! warning 注意事项</p>
<ul>
<li>应尽量选择体积小的镜像构建，有助于提升性能和资源的使用比<br />
!!!</li>
</ul>
<h2 id="label">LABEL</h2>
<p>!!!  note 基本信息</p>
<ul>
<li>用途
<ul>
<li>指定元数据，用于标识系统地址、用户、帐号、维护者等公开信息</li>
</ul>
</li>
<li>格式
<ul>
<li>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...<br />
!!!</li>
</ul>
</li>
</ul>
<p>!!! tip 常见用法</p>
<ul>
<li>维护者信息<div><pre class="hljs"><code><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">"alfiecheung &lt;root@alfiecheung.com&gt;"</span></span></code></pre></div>
</li>
</ul>
<p>!!!</p>
<p>!!! warning 注意事项<br />
无<br />
!!!</p>
<h2 id="run">RUN</h2>
<p>!!!  note 基本信息</p>
<ul>
<li>用途
<ul>
<li>用来在<code>构建镜像</code>阶段需要执行 FROM 指定镜像所支持的Shell命令</li>
</ul>
</li>
<li>格式<div><pre class="hljs"><code><span class="hljs-comment">#shell 格式: 相当于 /bin/sh -c</span>
&lt;命令&gt;
此种形式支持环境变量
<span class="hljs-keyword">RUN</span><span class="language-bash"> &lt;命令&gt;</span>
<span class="hljs-comment">#exec 格式: 此种形式不支持环境变量,注意:是双引号,不能是单引号</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">"executable"</span>,<span class="hljs-string">"param1"</span>,<span class="hljs-string">"param2"</span>...]</span>
<span class="hljs-comment">#exec格式可以指定其它shell</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">"/bin/bash"</span>,<span class="hljs-string">"-c"</span>,<span class="hljs-string">"echo hello wang"</span>]</span></code></pre></div>
</li>
</ul>
<p>!!!</p>
<p>!!! tip 常见用法</p>
<div><pre class="hljs"><code><span class="hljs-comment"># 多个命令通过 &amp;&amp; 操作符联合，为的是减少构建时的层数</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install epel-release \
    &amp;&amp; yum -y install nginx \
    &amp;&amp; rm -rf /usr/share/nginx/html/*</span>
    &amp;&amp; echo <span class="hljs-string">"&lt;h1&gt; docker test nginx &lt;/h1&gt;"</span> &gt; /usr/share/nginx/html/index.html</code></pre></div>
<p>!!!</p>
<p>!!! warning 注意事项</p>
<ul>
<li>
<p>shell格式命令，默认使用<code>/bin/sh</code>去解析，具有较多的限制性</p>
</li>
<li>
<p>exec格式命令，可通过修改<code>第一个变量</code>为所需的<code>shell</code>进行命令那个解析</p>
</li>
<li>
<p>命令执行没有上下文，如下执行是错误的</p>
</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-comment">#world.txt并不存放在/app内</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /app</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello"</span> &gt; world.txt</span>

<span class="hljs-comment"># 应修改为</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello"</span> &gt; /app/world.txt</span></code></pre></div>
<p>!!!</p>
<h2 id="env">ENV</h2>
<p>!!!  note 基本信息</p>
<ul>
<li>用途
<ul>
<li>环境变量的设置</li>
</ul>
</li>
<li>格式<div><pre class="hljs"><code><span class="hljs-comment">#变量赋值格式1</span>
<span class="hljs-comment">#此格式只能对一个key赋值,&lt;key&gt;之后的所有内容均会被视作其&lt;value&gt;的组成部分</span>
<span class="hljs-keyword">ENV</span> &lt;key&gt; &lt;value&gt;

<span class="hljs-comment">#变量赋值格式2</span>
<span class="hljs-comment">#此格式可以支持多个key赋值,定义多个变量建议使用,减少镜像层</span>
<span class="hljs-keyword">ENV</span> &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;</code></pre></div>
</li>
</ul>
<p>!!!</p>
<p>!!! tip 常见用法</p>
<ol>
<li>
<p>配置应用程序参数</p>
<div><pre class="hljs"><code><span class="hljs-keyword">ENV</span> DATABASE_HOST=localhost
<span class="hljs-keyword">ENV</span> DATABASE_PORT=<span class="hljs-number">5432</span>
<span class="hljs-keyword">ENV</span> API_KEY=abc123</code></pre></div>
</li>
<li>
<p>指定工作目录</p>
<div><pre class="hljs"><code><span class="hljs-keyword">ENV</span> APP_HOME=/app
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$APP_HOME</span></span></code></pre></div>
</li>
<li>
<p>设置语言环境</p>
<div><pre class="hljs"><code><span class="hljs-keyword">ENV</span> LANG=en_US.UTF-<span class="hljs-number">8</span>
<span class="hljs-keyword">ENV</span> LC_ALL=en_US.UTF-<span class="hljs-number">8</span></code></pre></div>
</li>
<li>
<p>传递构建参数</p>
<div><pre class="hljs"><code><span class="hljs-keyword">ARG</span> VERSION
<span class="hljs-keyword">ENV</span> APP_VERSION=$VERSION</code></pre></div>
</li>
</ol>
<p>!!!</p>
<p>!!! warning 注意事项</p>
<ul>
<li>ENV 可以定义环境变量和值</li>
<li>能被后续指令(如:ENV,ADD,COPY,RUN等)通过$KEY或${KEY}<code>进行引用</code>，并在容器<code>运行时保持</code><div><pre class="hljs"><code><span class="hljs-keyword">FROM</span>  rockylinux:<span class="hljs-number">9.3</span> 
<span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">"alfiecheung &lt;root@alfiecheung.com&gt;"</span></span>
<span class="hljs-keyword">ENV</span> name=<span class="hljs-string">"leslie"</span> age=<span class="hljs-number">20</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">${name}</span>:<span class="hljs-variable">${age}</span>"</span> &gt; /tmp/test.txt</span>

<span class="hljs-comment"># 通过运行容器，查看 /tmp/test.txt</span>
<span class="hljs-comment"># docker run --rm rocky:env-test2 cat /tmp/test.txt</span>
<span class="hljs-comment"># leslie:20</span></code></pre></div>
</li>
</ul>
<p>!!!</p>
<h2 id="copy">COPY</h2>
<p>!!!  note 基本信息</p>
<ul>
<li>用途
<ul>
<li>本地宿主机与容器之间文件的互相复制</li>
</ul>
</li>
<li>格式<div><pre class="hljs"><code><span class="hljs-keyword">COPY</span><span class="language-bash"> [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span>
<span class="hljs-keyword">COPY</span><span class="language-bash"> [--chown=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">"&lt;src&gt;"</span>,... <span class="hljs-string">"&lt;dest&gt;"</span>] <span class="hljs-comment">#路径中有空白字符时,建议使用此格式</span></span></code></pre></div>
</li>
</ul>
<p>!!!</p>
<p>!!! tip 常见用法</p>
<ol>
<li>
<p><strong>复制单个文件</strong>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">COPY</span><span class="language-bash"> source.txt /app/destination.txt</span></code></pre></div>
<p>将主机上的 <code>source.txt</code> 文件复制到容器中的 <code>/app/destination.txt</code>。</p>
</li>
<li>
<p><strong>复制整个目录</strong>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">COPY</span><span class="language-bash"> source_directory /app/destination_directory</span></code></pre></div>
<p>将主机上的 <code>source_directory</code> 目录及其所有内容递归地复制到容器中的 <code>/app/destination_directory</code>。</p>
</li>
<li>
<p><strong>复制多个文件</strong>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">COPY</span><span class="language-bash"> file1.txt file2.txt /app/</span></code></pre></div>
<p>将主机上的 <code>file1.txt</code> 和 <code>file2.txt</code> 文件复制到容器中的 <code>/app/</code> 目录。</p>
</li>
<li>
<p><strong>使用通配符复制多个文件</strong>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">COPY</span><span class="language-bash"> *.txt /app/</span></code></pre></div>
<p>将主机上所有以 <code>.txt</code> 结尾的文件复制到容器中的 <code>/app/</code> 目录。</p>
</li>
<li>
<p><strong>复制远程文件</strong>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">COPY</span><span class="language-bash"> https://example.com/file.txt /app/</span></code></pre></div>
<p>从远程 URL 下载文件 <code>file.txt</code> 并复制到容器中的 <code>/app/</code> 目录。</p>
</li>
<li>
<p><strong>复制文件并更改权限</strong>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">COPY</span><span class="language-bash"> --chown=user:group source.txt /app/destination.txt</span></code></pre></div>
<p>将主机上的 <code>source.txt</code> 文件复制到容器中的 <code>/app/destination.txt</code>，并将文件的所有者设置为 <code>user</code>，组设置为 <code>group</code>。</p>
</li>
<li>
<p><strong>复制文件到特定构建阶段</strong>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> builder as build
<span class="hljs-keyword">COPY</span><span class="language-bash"> source.txt /app/destination.txt</span></code></pre></div>
<p>在多阶段构建中，将 <code>source.txt</code> 文件从 <code>builder</code> 阶段复制到 <code>build</code> 阶段的容器中。<br />
!!!</p>
</li>
</ol>
<p>!!! warning 注意事项</p>
<ul>
<li><code>源文件路径</code>
<ul>
<li>COPY 命令的第一个参数是源文件或目录的路径。</li>
<li>在指定路径时，可以是相对于 <code>Dockerfile</code> 所在目录的相对路径，也可以是一个<code>绝对路径</code>。</li>
</ul>
</li>
<li><code>目标路径</code>
<ul>
<li>COPY 命令的第二个参数是目标路径，表示要将源文件或目录复制到容器中的位置。</li>
<li>这个路径可以是容器内的绝对路径，也可以是相对于容器工作目录的路径。如果目标路径不存在，则会<code>自动创建</code>。</li>
</ul>
</li>
<li><code>目录复制</code>
<ul>
<li>如果源路径是一个目录，COPY 命令将<code>递归地复制该目录及其所有内容</code>，但<code>不复制目录自身</code>。</li>
<li>目标路径必须是一个已存在的目录，或者在构建过程中已经创建。</li>
</ul>
</li>
<li><code>文件权限</code>
<ul>
<li>使用 COPY 命令复制文件时，文件的<code>权限将保持不变</code>。</li>
<li>如果需要更改文件的权限，可以<code>使用 RUN 命令在 Dockerfile 中进行相应的权限</code>更改操作。</li>
</ul>
</li>
<li><code>使用通配符</code>
<ul>
<li>COPY 命令支持使用通配符来复制多个文件。</li>
<li>例如，<code>COPY *.txt /app/</code> 将复制所有以 <code>.txt</code> 结尾的文件到容器的 <code>/app/</code> 目录。</li>
</ul>
</li>
<li><code>多个复制操作</code>
<ul>
<li>可以在 Dockerfile 中使用多个 COPY 命令来复制不同的文件或目录到容器中。</li>
<li>这些复制操作将按照在 Dockerfile 中的顺序依次执行。</li>
</ul>
</li>
<li><code>文件排除</code>
<ul>
<li>可以使用 <code>.dockerignore</code> 文件来排除不需要复制到镜像中的文件和目录。</li>
<li><code>.dockerignore</code> 文件的格式类似于 .gitignore 文件，可以通过添加规则来过滤文件和目录。</li>
</ul>
</li>
</ul>
<p>!!!</p>
<h2 id="add">ADD</h2>
<p>!!!  note 基本信息</p>
<ul>
<li>用途
<ul>
<li>支持将压缩文件进行复制解压</li>
</ul>
</li>
<li>格式<div><pre class="hljs"><code><span class="hljs-keyword">ADD</span><span class="language-bash"> [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span>
<span class="hljs-keyword">ADD</span><span class="language-bash"> [--chown=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">"&lt;src&gt;"</span>,... <span class="hljs-string">"&lt;dest&gt;"</span>]</span></code></pre></div>
</li>
</ul>
<p>!!!</p>
<p>!!! warning 注意事项</p>
<ul>
<li>如果是一个 <code>URL</code> ，下载后的文件权限自动设置为 <code>600</code></li>
<li>如果是一个本地文件系统上的打包文件,如: gz, bz2 ,xz ，它将被解包 ，其行为类似于"tar -x"命令, 但是<code>通过URL获取到的tar文件</code>将<code>不会自动展开</code><br />
!!!</li>
</ul>
<h2 id="cmd">CMD</h2>
<p><img src="/_resources/1e3b9a8514b142cf874428f42050682d.png" /><br />
!!!  note 基本信息</p>
<ul>
<li>用途
<ul>
<li>设置容器启动时要执行的<code>默认命令</code></li>
</ul>
</li>
<li>格式<div><pre class="hljs"><code><span class="hljs-comment"># 使用 exec 执行，推荐方式，第一个参数必须是命令的全路径,此种形式不支持环境变量</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">"executable"</span>,<span class="hljs-string">"param1"</span>,<span class="hljs-string">"param2"</span>]</span>

<span class="hljs-comment"># 在 /bin/sh 中执行，提供给需要交互的应用；此种形式支持环境变量</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">command</span> param1 param2</span>

<span class="hljs-comment"># 提供给 ENTRYPOINT 命令的默认参数</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">"param1"</span>,<span class="hljs-string">"param2"</span>]</span></code></pre></div>
</li>
</ul>
<p>!!!</p>
<p>!!! tip 常见用法</p>
<ol>
<li>
<p><strong>执行单个命令</strong>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"Hello, Docker!"</span></span></code></pre></div>
<p>在容器启动时执行 <code>echo "Hello, Docker!"</code> 命令。</p>
</li>
<li>
<p><strong>执行可执行文件</strong>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">CMD</span><span class="language-bash"> ./myapp</span></code></pre></div>
<p>在容器启动时执行名为 <code>myapp</code> 的可执行文件。</p>
</li>
<li>
<p><strong>指定命令和参数</strong>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">"python"</span>, <span class="hljs-string">"app.py"</span>]</span></code></pre></div>
<p>在容器启动时执行 <code>python app.py</code> 命令。</p>
</li>
<li>
<p><strong>使用 Shell 执行命令</strong>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">CMD</span><span class="language-bash"> bash -c <span class="hljs-string">"echo Welcome; echo to Docker"</span></span></code></pre></div>
<p>在容器启动时使用 Shell 执行复杂的命令或命令序列。</p>
</li>
<li>
<p><strong>覆盖 CMD</strong>:<br />
在运行容器时，可以使用 <code>docker run</code> 命令的参数来覆盖 <code>CMD</code> 命令。例如：</p>
<div><pre class="hljs"><code>docker run myimage echo "Hello, World!"</code></pre></div>
<p>这将在容器运行时覆盖默认的 <code>CMD</code> 命令，并执行 <code>echo "Hello, World!"</code>。</p>
</li>
<li>
<p><strong>作为ENTRYPOINT的参数</strong>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">"echo"</span>, <span class="hljs-string">"Hello,"</span>]</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">"Docker!"</span>]</span></code></pre></div>
</li>
</ol>
<p>!!!</p>
<p>!!! warning 注意事项</p>
<ol>
<li>作为默认执行命令
<ul>
<li><code>dockerfile</code> 里面没有<code>ENTRYPOINT命令</code> 且 <code>docker run</code>没有指定执行命令时</li>
</ul>
</li>
<li>最有最后一条生效
<ul>
<li>如果在<code>dockerfile</code> 中添加多个 <code>CMD</code>命令，后添加的<code>CMD</code>命令将覆盖前面添加的</li>
</ul>
</li>
<li>可以被替换
<ul>
<li><code>docker run</code>运行容器的过程中，可以指定<code>需要执行的命令</code>，这个命令将替代<code>dockerfile CMD</code>命令<br />
!!!</li>
</ul>
</li>
</ol>
<h2 id="entrypoint">ENTRYPOINT</h2>
<p><img src="/_resources/29ff5ff778c24015b5cffb4ccd8033ee.png" /><br />
!!!  note 基本信息</p>
<ul>
<li>用途
<ul>
<li>用于指定在容器启动时要<code>执行的可执行命令或脚本</code>。</li>
</ul>
</li>
<li>格式<div><pre class="hljs"><code><span class="hljs-comment"># 使用 exec 执行</span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">"executable"</span>, <span class="hljs-string">"param1"</span>, <span class="hljs-string">"param2"</span>...]</span>
<span class="hljs-comment"># shell中执行</span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> <span class="hljs-built_in">command</span> param1 param2</span></code></pre></div>
</li>
</ul>
<p>!!!</p>
<p>!!! tip 常见用法</p>
<ul>
<li>
<p>运行环境配置</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span>  rockylinux:<span class="hljs-number">9.3</span>
<span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">"alfiecheung &lt;root@alfiecheung.com&gt;"</span></span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> sed -e <span class="hljs-string">'s|^mirrorlist=|#mirrorlist=|g'</span> \
    -e <span class="hljs-string">'s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g'</span> \
    -i.bak /etc/yum.repos.d/rocky-*.repo </span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> dnf install -y nginx &amp;&amp;  rm -rf /var/cache/dnf/*</span>

<span class="hljs-keyword">COPY</span><span class="language-bash"> entry.sh /tmp</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> chmod a+x /tmp/entry.sh</span>

<span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">"/tmp/entry.sh"</span>]</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">"nginx"</span>, <span class="hljs-string">"-g"</span>, <span class="hljs-string">"daemon off;"</span>]</span></code></pre></div>
<div><pre class="hljs"><code><span class="hljs-meta">#!/bin/sh</span>
<span class="hljs-comment"># 创建nginx配置文件</span>
<span class="hljs-comment"># 变量可以使用默认变量值（即 :- 后的内容）</span>
<span class="hljs-comment"># 或通过 ENV / docker run -e 提供变量内容进行覆盖</span>
cat &gt; /etc/nginx/conf.d/custome.conf &lt;&lt;<span class="hljs-string">EOF
server {
  server_name ${HOSTNAME:-"wwww.alopex.com"};
  listen ${IP:-"0.0.0.0"}:${PORT:-8080};
  root ${DOC_ROOT:-"/usr/share/nginx/html"};
}
EOF</span>

<span class="hljs-comment"># 创建目录</span>
mkdir -p <span class="hljs-variable">${DOC_ROOT:-/usr/share/nginx/html}</span>

<span class="hljs-comment"># 自定义主页</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">${HOSTNAME:-"www.alopex.com"}</span> &gt; <span class="hljs-variable">${DOC_ROOT:-/usr/share/nginx/html}</span>/index.html

<span class="hljs-comment"># 通过exec接受CMD“参数”/ docker run “命令”</span>
<span class="hljs-comment"># 由于exec 内建命令可替换当前shell，因此首命令可由用户指定需要执行的命令，而不仅仅只是参数传递</span>
<span class="hljs-comment"># 提高了脚本的灵活性，是一个约定成俗的操作</span>
<span class="hljs-built_in">exec</span> <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span></code></pre></div>
<div><pre class="hljs"><code><span class="hljs-comment"># 创建镜像</span>
docker build -t rocky-nginx:entry-v2 .

<span class="hljs-comment"># 启动容器</span>
<span class="hljs-comment">## 自定义hostname和port变量，能够在配置中修改</span>
docker run -d -e PORT=9090 \
-e HOSTNAME=<span class="hljs-string">"www.leslie.com"</span> \
-e DOC_ROOT=<span class="hljs-string">"/tmp/cc"</span> rocky-nginx:entry-v2

<span class="hljs-comment"># 测试容器</span>
curl ip.ip.ip.ip:9090</code></pre></div>
</li>
</ul>
<p>!!!</p>
<p>!!! warning 注意事项</p>
<ol>
<li>ENTRYPOINT接收docker run参数
<ul>
<li><code>docker run</code>提供的命令无法替换<code>ENTRYPOINT</code>，相反该命令将作为参数传递给<code>ENTRYPOINT</code></li>
<li>参数优先级
<ul>
<li><code>docker run</code></li>
<li><code>CMD</code></li>
</ul>
</li>
</ul>
</li>
<li>最有最后一条生效
<ul>
<li>如果在<code>dockerfile</code> 中添加多个 <code>ENTRYPOINT</code>命令，后添加的<code>ENTRYPOINT</code>命令将覆盖前面添加的<br />
!!!</li>
</ul>
</li>
</ol>
<h2 id="arg">ARG</h2>
<p>!!!  note 基本信息</p>
<ul>
<li>用途
<ul>
<li>Build 阶段指定变量</li>
</ul>
</li>
<li>格式
<ul>
<li>ARG &lt;name&gt;[=&lt;default value&gt;]<br />
!!!</li>
</ul>
</li>
</ul>
<p>!!! tip 常见用法</p>
<ul>
<li>与FROM结合，在构建时始终使用追新的images<div><pre class="hljs"><code><span class="hljs-keyword">ARG</span> CODE_VERSION=latest
<span class="hljs-keyword">FROM</span> base:${CODE_VERSION}</code></pre></div>
</li>
</ul>
<p>!!!</p>
<p>!!! warning 注意事项</p>
<ul>
<li>唯一可以放置在<code>FROM</code>命令前的指令</li>
<li>ARG指令在build 阶段指定变量</li>
<li>和ENV不同的是，容器运行时并不存在ARG定义的环境变量</li>
<li>可以用 docker build --build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖<br />
!!!</li>
</ul>
<h2 id="volume">VOLUME</h2>
<p>!!!  note 基本信息</p>
<ul>
<li>用途
<ul>
<li>创建匿名卷</li>
<li>容器删除后默认将删除容器内数据，匿名卷是数据持久话的一个实现手段</li>
<li>持久化可以使得容器在删除后，挂载的匿名卷目录将继续保留</li>
<li>更多详细内容 <a>0x06 docker/存储管理</a></li>
</ul>
</li>
<li>格式<div><pre class="hljs"><code><span class="hljs-keyword">VOLUME</span><span class="language-bash"> &lt;容器内路径&gt;</span>
<span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">"&lt;容器内路径1&gt;"</span>, <span class="hljs-string">"&lt;容器内路径2&gt;"</span>...]</span>
注意:
&lt;容器内路径&gt;如果在容器内不存在,在创建容器时会自动创建
&lt;容器内路径&gt;如果是存在的,同时目录内有内容,将会把此目录的内容复制到宿主机的实际目录</code></pre></div>
</li>
</ul>
<p>!!!</p>
<p>!!! tip 常见用法</p>
<ul>
<li>挂载两个匿名卷
<ul>
<li>VOLUME [ "/data1","/data2" ]<br />
!!!</li>
</ul>
</li>
</ul>
<p>!!! warning 注意事项</p>
<ol>
<li>匿名卷默认路径<code>/var/lib/docker/volumes</code></li>
<li>数据存储目录 <code>/var/lib/docker/volumes/&lt;container-id&gt;/_data</code></li>
<li>匿名卷创建宿主机和镜像都<code>不需要要事先存在真实目录</code></li>
<li>挂载的匿名卷目录将在容器内自动创建</li>
<li>匿名卷无有效名称虽然<code>可保留数据</code>但<code>复用性不强</code>，容器删除后难以获取卷名称 (即数据保留的匿名卷)
<ul>
<li>容器挂载卷名称获取: <code>docker inspect --format '{{range .Mounts}}{{.Name}}{{end}}' &lt;container-id&gt;</code></li>
<li>名称例子：<code>9bcb9d85be8480d83e31ba6f08ba08c5669220c424a6313b318b2850e24353ba</code><br />
!!!</li>
</ul>
</li>
</ol>
<h2 id="expose">EXPOSE</h2>
<p>!!!  note 基本信息</p>
<ul>
<li>用途
<ul>
<li>用于启动容器时，端口暴露的标识</li>
</ul>
</li>
<li>格式<div><pre class="hljs"><code><span class="hljs-keyword">EXPOSE</span> &lt;port&gt;[/ &lt;protocol&gt;] [&lt;port&gt;[/ &lt;protocol&gt;] ..]</code></pre></div>
</li>
</ul>
<p>!!!</p>
<p>!!! tip 常见用法</p>
<ul>
<li>暴露特定端口和协议
<ul>
<li>EXPOSE 11211/udp 11211/tcp<br />
!!!</li>
</ul>
</li>
</ul>
<p>!!! warning 注意事项</p>
<ol>
<li>EXPOSE仅仅只是一个便捷标识，并不意味这容器就使用其暴露的端口</li>
<li>EXPOSE主要是和<code>—P</code>临时端口映射配合使用，使用端口并非一定需要通过该语句暴露，也可以使用<code>-p host-port:container-port</code><br />
!!!</li>
</ol>
<h2 id="workdir">WORKDIR</h2>
<p>!!!  note 基本信息</p>
<ul>
<li>用途
<ul>
<li>指定工作目录</li>
<li>为后续的 <code>RUN, CMD, ENTRYPOINT</code> 指令配置工作目录，当容器运行后，进入容器内WORKDIR指定的默认目录</li>
</ul>
</li>
<li>格式
<ul>
<li></li>
</ul>
</li>
</ul>
<p>!!!</p>
<p>!!! tip 常见用法</p>
<ul>
<li>指定当前的工作目录
<ul>
<li>WORKDIR /path/to/workdir<br />
!!!</li>
</ul>
</li>
</ul>
<p>!!! warning 注意事项</p>
<ol>
<li>指定存在的<code>workdir</code>将会被自动创建</li>
<li>在RUN可以生效,在CMD、ENTRYPOINT可能会有问题<br />
!!!</li>
</ol>
<h2 id="onbuild">ONBUILD</h2>
<p>!!!  note 基本信息</p>
<ul>
<li>用途
<ul>
<li>子镜像调用父镜像是执行的命令</li>
</ul>
</li>
<li>格式
<ul>
<li>ONBUILD [INSTRUCTION]<br />
!!!</li>
</ul>
</li>
</ul>
<p>!!! tip 常见用法</p>
<ul>
<li>通过该父镜像创建的子镜像都需要打上标签
<ul>
<li>ONBUILD RUN echo "alopex copyright C" &gt; /etc/parent-os<br />
!!!</li>
</ul>
</li>
</ul>
<p>!!! warning 注意事项</p>
<ol>
<li>ONBUILD不能自我能套，且不会触发FROM和MAINTAINER指令</li>
<li>推荐在标签中注明，例如 <code>ruby:1.9-onbuild</code></li>
<li>ONBUILD命令只能实现单次传递(直接继承的子代)，不会持续传递(间接继承的子代)<br />
!!!</li>
</ol>
<h2 id="user">USER</h2>
<p>!!!  note 基本信息</p>
<ul>
<li>用途
<ul>
<li>指定默认的容器运行用户名称或UID</li>
<li>后续dockerfile中的 RUN ，CMD和ENTRYPOINT指令时使用此用户</li>
</ul>
</li>
<li>格式<div><pre class="hljs"><code><span class="hljs-keyword">USER</span> &lt;<span class="hljs-keyword">user</span>&gt;[:&lt;group&gt;]
<span class="hljs-keyword">USER</span> &lt;UID&gt;[:&lt;GID&gt;]</code></pre></div>
</li>
</ul>
<p>!!!</p>
<p>!!! tip 常见用法</p>
<ul>
<li>为数据库用户创建<code>musql</code>用户<div><pre class="hljs"><code><span class="hljs-keyword">RUN</span><span class="language-bash"> groupadd -r mysql &amp;&amp; useradd -r -g mysql mysql</span>
<span class="hljs-keyword">USER</span> mysql</code></pre></div>
</li>
</ul>
<p>!!!</p>
<p>!!! warning 注意事项<br />
无<br />
!!!</p>
<h2 id="healthcheck">HEALTHCHECK</h2>
<p>!!!  note 基本信息</p>
<ul>
<li>用途
<ul>
<li>容器启动后的状态检测，确认容器是否按照预订要求运行</li>
</ul>
</li>
<li>格式<div><pre class="hljs"><code><span class="hljs-keyword">HEALTHCHECK</span><span class="language-bash"> [选项] CMD &lt;命令&gt; <span class="hljs-comment">#设置检查容器健康状况的命令,如果命令执行失败,则返回1,即 unhealthy</span></span>
<span class="hljs-keyword">HEALTHCHECK</span><span class="language-bash"> NONE <span class="hljs-comment">#如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</span></span>

<span class="hljs-keyword">HEALTHCHECK</span><span class="language-bash"> 支持下列选项:</span>
--interval=&lt;间隔&gt; <span class="hljs-comment">#两次健康检查的间隔，默认为 30 秒</span>
--timeout=&lt;时长&gt; <span class="hljs-comment">#健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒</span>
--retries=&lt;次数&gt; <span class="hljs-comment">#当连续失败指定次数后，则将容器状态视为 unhealthy，默认3次</span>
--start-period=&lt;FDURATION&gt; <span class="hljs-comment">#default: 0s </span>

<span class="hljs-comment">#检查结果返回值:</span>
<span class="hljs-number">0</span>  <span class="hljs-comment">#success the container is healthy and ready for use</span>
<span class="hljs-number">1</span>  <span class="hljs-comment">#unhealthythe container is not working correctly</span>
<span class="hljs-number">2</span>  <span class="hljs-comment">#reserveddo not use this exit code</span></code></pre></div>
</li>
</ul>
<p>!!!</p>
<p>!!! tip 常见用法</p>
<ul>
<li>检测80请求是否正常<div><pre class="hljs"><code><span class="hljs-keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5s --timeout=3s CMD curl -fs http://127.0.0.1:90/</span></code></pre></div>
</li>
</ul>
<p>!!!</p>
<p>!!! warning 注意事项</p>
<ol>
<li>healthcheck 是认为设定检测规则，unhealthy表示检测状态异常但不代表容器服务不可用</li>
<li>对于启动时间较长的容器，建起增大<code>timeout</code>时间</li>
<li>容器检查会造成额外的内部资源消耗<br />
!!!</li>
</ol>
<h3 id="dockerignore-文件">.dockerignore 文件</h3>
<p>!!!  note 基本信息</p>
<ul>
<li>用途
<ul>
<li>生成构建上下文时Docker客户端<code>忽略指定模式文件和文件夹</code></li>
</ul>
</li>
<li>格式<div><pre class="hljs"><code>#	#以#开头的行为注释
*	#匹配任何非分隔符字符序列
?	#匹配任何单个非分隔符
\\	#表示
**	#匹配任意数量的目录（包括零）例如，**<span class="hljs-comment">/*.go将排除在所有目录中以.go结尾的所有文件，包括构建上下文的根。
!	#表示取反，可用于排除例外情况</span></code></pre></div>
</li>
</ul>
<p>!!!</p>
<p>!!! tip 常见用法</p>
<div><pre class="hljs"><code><span class="hljs-comment">#排除 test 目录下的所有文件</span>
test/*
<span class="hljs-comment">#排除 md 目录下的 xttblog.md 文件</span>
md/xttblog.md
<span class="hljs-comment">#排除 xttblog 目录下的所有 .md 的文件</span>
xttblog/*<span class="hljs-string">.md</span>
<span class="hljs-comment">#排除以 xttblog 为前缀的文件和文件夹</span>
xttblog?
<span class="hljs-comment">#排除所有目录下的 .sql 文件夹</span>
**/*<span class="hljs-string">.sql</span></code></pre></div>
<p>!!!</p>
<p>!!! warning 注意事项</p>
<ul>
<li>通过创建<code>.dockerignore</code>文件实现<br />
!!!</li>
</ul>
<h1 id="docker-网络模式">Docker 网络模式</h1>
<h1 id="harbor私有仓库">Harbor私有仓库</h1>
<h1 id="jumpserver安装和使用">JumpServer安装和使用</h1>
</div>
      </article>
    </div>
  </body>
</html>
