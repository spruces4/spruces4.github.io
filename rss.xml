<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title></title>
        <link>undefined</link>
        <description>undefined</description>
        <lastBuildDate>Sun, 14 Apr 2024 05:07:42 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Joplin Pages Publisher</generator>
        <item>
            <title><![CDATA[第二周作业]]></title>
            <guid>c512f8c02d02485293c57f2e4b863f51</guid>
            <pubDate>Sun, 14 Apr 2024 04:06:22 GMT</pubDate>
            <content:encoded><![CDATA[<nav class="table-of-contents"><ul><li><a href="#各版本zabbix安装">各版本zabbix安装</a><ul><li><a href="#安装">安装</a></li><li><a href="#rpm系包安装">rpm系包安装</a></li><li><a href="#dpkg系包安装">dpkg系包安装</a></li></ul></li><li><a href="#主动模式和被动模式比较与实现">主动模式和被动模式比较与实现</a><ul><li><a href="#被动模式默认">被动模式(默认)</a></li><li><a href="#主动模式">主动模式</a></li><li><a href="#配置">配置</a><ul><li><a href="#配置-1">配置</a></li></ul></li></ul></li><li><a href="#proxy主动被动模式案例">proxy主动被动模式案例</a><ul><li><a href="#原理">原理</a></li><li><a href="#架构">架构</a></li><li><a href="#安装proxy">安装proxy</a></li><li><a href="#工作模式">工作模式</a></li><li><a href="#主动模式-1">主动模式</a><ul><li><a href="#proxy文件">proxy文件</a></li><li><a href="#agent文件">agent文件</a></li><li><a href="#前端配置">前端配置</a></li><li><a href="#验证监控">验证监控</a></li></ul></li><li><a href="#被动模式">被动模式</a><ul><li><a href="#proxy数据库修改">proxy数据库修改</a></li><li><a href="#proxy文件-1">proxy文件</a></li><li><a href="#agent文件-1">agent文件</a></li><li><a href="#前端配置-1">前端配置</a></li><li><a href="#验证监控-1">验证监控</a></li></ul></li><li><a href="#参考">参考</a></li></ul></li><li><a href="#一键zabbix-agent脚本">一键zabbix agent脚本</a></li><li><a href="#一键zabbix-api添加zabbix-agent">一键zabbix api添加zabbix agent</a><ul><li><a href="#api_create-被动模式">api_create (被动模式)</a></li><li><a href="#api_create-主动模式">api_create (主动模式)</a></li></ul></li></ul></nav><h1 id="各版本zabbix安装">各版本zabbix安装</h1>
<h2 id="安装">安装</h2>
<blockquote>
<p><a title="https://www.zabbix.com/download" href="https://www.zabbix.com/download">官方下载链接</a></p>
</blockquote>
<p>!!! warning 注意事项</p>
<ol>
<li>font-end 为 apache, 前端访问地址： <a title="http://host/zabbix" href="http://host/zabbix">http://host/zabbix</a></li>
<li>font-end 为 nginx (zabbix 6.0 后支持), 前端访问地址 http://host_name/<br />
!!!</li>
</ol>
<h2 id="rpm系包安装">rpm系包安装</h2>
<div><pre class="hljs"><code><span class="hljs-comment"># 安装6.0LTS / Rocky Linux 8 / server, fronted, agent / mysql / Apache</span>

1. 关闭epel源的zabbix项
[epel]
...
excludepkgs=zabbix*

2. 安装zabbix仓库
rpm -Uvh https://repo.zabbix.com/zabbix/6.0/rhel/8/x86_64/zabbix-release-6.0-4.el8.noarch.rpm
dnf clean all

3. 安装
dnf install zabbix-server-mysql \
zabbix-web-mysql zabbix-apache-conf \
zabbix-sql-scripts zabbix-selinux-policy \
zabbix-agent mysql-server mysql

4. 创建数据库
mysql -uroot -p
&gt;  password
&gt;  mysql&gt; create database zabbix character <span class="hljs-built_in">set</span> utf8mb4 collate utf8mb4_bin; -- 创建用户zabbix设定字符集等
&gt;  mysql&gt; create user zabbix@localhost identified by <span class="hljs-string">'alopex'</span>; -- 修改用户zabbix的密码
&gt;  mysql&gt; grant all privileges on zabbix.* to zabbix@localhost; -- localhost修改为对应的主机
&gt;  mysql&gt; <span class="hljs-built_in">set</span> global log_bin_trust_function_creators = 1; -- 允许在MySQL服务器中创建并使用自定义函数
&gt;  mysql&gt; quit;

5. 导入数据库脚本
zcat /usr/share/zabbix-sql-scripts/mysql/server.sql.gz | mysql --default-character-set=utf8mb4 -uzabbix -p zabbix
mysql -uroot -p
&gt;  password
&gt;  mysql&gt; <span class="hljs-built_in">set</span> global log_bin_trust_function_creators = 0;  -- 关闭在MySQL服务器中创建并使用自定义函数
&gt;  mysql&gt; quit;

6. 修改zabbix server的DB密码
 /etc/zabbix/zabbix_server.conf
 DBPassword=alopex

7. 设置zabbix开机启动
systemctl restart zabbix-server zabbix-agent httpd php-fpm mysqld.service
systemctl <span class="hljs-built_in">enable</span> zabbix-server zabbix-agent httpd php-fpm mysqld.service

8. 打开zabbix UI访问界面，初始化数据库
...</code></pre></div>
<p><img src="/_resources/e1a831264873427984995344f79d2fb4.png" /><br />
<img src="/_resources/56c0a7b4e10e418eb136f9c2cdf49792.png" /></p>
<h2 id="dpkg系包安装">dpkg系包安装</h2>
<div><pre class="hljs"><code><span class="hljs-comment"># 安装6.0LTS / ubuntu 22.04 / server, fronted, agent / mysql / Nginx</span>

1. 安装zabbix仓库
wget https://repo.zabbix.com/zabbix/6.0/ubuntu/pool/main/z/zabbix-release/zabbix-release_6.0-4+ubuntu22.04_all.deb
dpkg -i zabbix-release_6.0-4+ubuntu22.04_all.deb
apt update

2. 安装
apt install zabbix-server-mysql \
zabbix-frontend-php zabbix-nginx-conf \
zabbix-sql-scripts zabbix-agent \
mysql-server mysql-client

3. 创建数据库
mysql -uroot -p
&gt;  password
&gt;  mysql&gt; create database zabbix character <span class="hljs-built_in">set</span> utf8mb4 collate utf8mb4_bin; -- 创建用户zabbix设定字符集等
&gt;  mysql&gt; create user zabbix@localhost identified by <span class="hljs-string">'alopex'</span>; -- 修改用户zabbix的密码
&gt;  mysql&gt; grant all privileges on zabbix.* to zabbix@localhost; -- localhost修改为对应的主机
&gt;  mysql&gt; <span class="hljs-built_in">set</span> global log_bin_trust_function_creators = 1; -- 允许在MySQL服务器中创建并使用自定义函数
&gt;  mysql&gt; quit;

4. 导入数据库脚本
zcat /usr/share/zabbix-sql-scripts/mysql/server.sql.gz | mysql --default-character-set=utf8mb4 -uzabbix -p zabbix
mysql -uroot -p
&gt;  password
&gt;  mysql&gt; <span class="hljs-built_in">set</span> global log_bin_trust_function_creators = 0;  -- 关闭在MySQL服务器中创建并使用自定义函数
&gt;  mysql&gt; quit;

5. 修改zabbix server的DB密码
 /etc/zabbix/zabbix_server.conf
 DBPassword=alopex

6. 关闭apache2
systemctl <span class="hljs-built_in">disable</span> --now apache2
 
6. 配置PHP前端 
/etc/zabbix/nginx.conf 
listen 8080;
server_name my_zabbix.com;  <span class="hljs-comment"># 修改服务器名称</span>

7. 追加hosts解析
<span class="hljs-built_in">echo</span> <span class="hljs-string">"ip.ip.ip.ip my_zabbix.com"</span>  | sudo tee -a /etc/hosts
 
7. 设置zabbix开机启动
systemctl restart zabbix-server zabbix-agent nginx php8.1-fpm mysql-service
systemctl <span class="hljs-built_in">enable</span> zabbix-server zabbix-agent nginx php8.1-fpm mysql-service
 
8. 打开zabbix UI访问界面，初始化数据库
...</code></pre></div>
<p><img src="/_resources/c699e7e06aeb4e87be124b34c3dcc22a.png" /><br />
<img src="/_resources/3146565c6a6b42fba65abfc137551a3e.png" /></p>
<h1 id="主动模式和被动模式比较与实现">主动模式和被动模式比较与实现</h1>
<h3 id="被动模式默认">被动模式(默认)</h3>
<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>通信方式</td>
<td>被动模式下,Zabbix Agent被动地等待来自Zabbix Server或Proxy的连接请求和数据收集指令。</td>
</tr>
<tr>
<td>工作特点</td>
<td>1) 定期被Zabbix Server或Proxy主动连接和查询 <br class="jop-noMdConv" /> 2) 监控本地资源和应用程序状态 <br class="jop-noMdConv" /> 3) 将收集的数据发送给Server或Proxy</td>
</tr>
<tr>
<td>适用场景</td>
<td>1) 中小规模环境,无需分布式监控 <br class="jop-noMdConv" /> 2) 防火墙限制,Agent无法主动连接Server <br class="jop-noMdConv" /> 3) 监控对象数量有限</td>
</tr>
<tr>
<td>系统负载</td>
<td>相对较低,Agent处理请求的负载较小</td>
</tr>
<tr>
<td>Agent监听端口</td>
<td>10050 (TCP) - 与Zabbix Server/Proxy通信 <br class="jop-noMdConv" /> 10049 (TCP) - 与Zabbix Server通信(仅被动模式)</td>
</tr>
<tr>
<td>Server/Proxy端口</td>
<td>10051 (TCP) - Zabbix Proxy的Trapper接收主动数据 <br class="jop-noMdConv" /> 10025 (TCP) - Server与Proxy、其他组件通信 <br class="jop-noMdConv" /> 10020 (TCP/UDP) - Server的SNMP Trapper与Agent通信</td>
</tr>
<tr>
<td>数据更新频率</td>
<td>由Zabbix Server或Proxy控制,默认60秒刷新一次被动项目。可根据需求进行配置调整。</td>
</tr>
</tbody>
</table>
<h3 id="主动模式">主动模式</h3>
<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>通信方式</td>
<td>主动模式下,Zabbix Agent主动连接Zabbix Server,不需要Server端主动查询。</td>
</tr>
<tr>
<td>工作特点</td>
<td>1) 主动连接并主动将监控数据发送给Zabbix Server <br class="jop-noMdConv" /> 2) 可在防火墙后工作,只需开启出站连接 <br class="jop-noMdConv" /> 3) 支持主动发送Trapper数据给Zabbix Server</td>
</tr>
<tr>
<td>适用场景</td>
<td>1) 分布式大规模环境,大量被监控对象 <br class="jop-noMdConv" /> 2) 防火墙限制,只允许主动出站连接 <br class="jop-noMdConv" /> 3) 监控对象分散在广域网络中</td>
</tr>
<tr>
<td>系统负载</td>
<td>相比被动模式,Agent端负载较高,需要主动建立连接。</td>
</tr>
<tr>
<td>Agent监听端口</td>
<td>不适用,没有监听端口。</td>
</tr>
<tr>
<td>Server端口</td>
<td>10051 (TCP) - Zabbix Server Trapper接收主动数据</td>
</tr>
<tr>
<td>数据更新频率</td>
<td>由Agent端控制,可根据配置进行主动更新,默认120秒。</td>
</tr>
</tbody>
</table>
<h2 id="配置">配置</h2>
<h4 id="配置-2">配置</h4>
<p>!!! abstract 配置信息</p>
<ul>
<li>
<p>被动模式 （默认模式）</p>
<ul>
<li>agent端文件配置  <code>/etc/zabbix/zabbix_agentd.conf</code><div><pre class="hljs"><code><span class="hljs-attr">Server</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">100.136</span> <span class="hljs-comment"># 指向zabbix server</span></code></pre></div>
</li>
<li>重启服务
<blockquote>
<p>systemctl restart zabbix-agent.service</p>
</blockquote>
</li>
<li>前端配置<br />
<img src="/_resources/67849c46e3dd4d82a45a7439f5157ed5.png" /><br />
<img src="/_resources/ed8fa3e798094f399af918df54701dda.png" /></li>
</ul>
</li>
<li>
<p>主动模式</p>
<ul>
<li>agent端文件配置  <code>/etc/zabbix/zabbix_agentd.conf</code><div><pre class="hljs"><code><span class="hljs-attr">Server</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">100.136</span> <span class="hljs-comment"># !强制! 指向zabbix server</span>
<span class="hljs-attr">ServerActive</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">100.136</span> <span class="hljs-comment"># !强制! zabbix服务器IP地址</span>
<span class="hljs-attr">Hostname</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">100.77</span> <span class="hljs-comment"># !强制! 当前主机IP，必须与zabbix server前端主机名称(Host name)相同</span>
<span class="hljs-attr">Timeout</span>=<span class="hljs-number">30</span>   <span class="hljs-comment"># （建议配置 超时时间）</span></code></pre></div>
</li>
<li>重启服务
<blockquote>
<p>systemctl restart zabbix-agent.service</p>
</blockquote>
</li>
<li>前端配置<br />
<img src="/_resources/aa0751cf9f3749cbb21777ada0e3828a.png" /><br />
<img src="/_resources/d240e7afc06c4a049de777af33d5aeb7.png" /></li>
</ul>
<blockquote>
<p>主动模式模板Linux by Zabbix agent active的agent.ping监控项ZBX标记不会变绿，需要修改<br />
为被动模式ZBX标记才能被绿 (可以通过添加 agent.ping 变绿)<br />
!!!</p>
</blockquote>
</li>
</ul>
<h1 id="proxy主动被动模式案例">proxy主动被动模式案例</h1>
<h2 id="原理">原理</h2>
<p>通过<code>zabbix proxy</code>将数据发送给<code>zabbix server</code>，一来减轻了<code>zabbix server</code>的负担，二来可以实现<code>分布式</code>监控，将分散在各处的数据汇集到同一个监控上。<br />
zabbix proxy 是一个数据收集器,它<code>不计算触发器</code>、<code>不处理事件</code>、<code>不发送报警</code>。</p>
<h2 id="架构">架构</h2>
<p><img src="/_resources/f0e00fc6403a489b8b81fdaa14e99036.png" /></p>
<ul>
<li><code>zabbix proxy</code>仅仅需要一条<code>tcp</code>连接到zabbix server，所以防火墙上仅仅需要加上一条规则即可。</li>
<li><code>zabbix proxy</code>数据库必须和<code>server</code>分开，否则数据会被破坏，毕竟这两个数据库的表大部分都相同。总之记住，数据库分开即可。</li>
<li><code>proxy</code>收集到数据之后，首先将数据缓存在本地，然后在<code>一定得时间</code>之后传递给<code>zabbix server</code>。</li>
<li>这个时间由proxy配置文件中参数<code>ProxyLocalBuffer</code> and <code>ProxyOfflineBuffer</code>决定。</li>
</ul>
<h2 id="安装proxy">安装proxy</h2>
<div><pre class="hljs"><code><span class="hljs-comment"># Rocky8 / Mysql</span>
1. 导入官方源
rpm -Uvh https://repo.zabbix.com/zabbix/6.0/rhel/8/x86_64/zabbix-release-6.0-4.el8.noarch.rpm
sed -i.bak <span class="hljs-string">'s/repo.zabbix.com/mirrors.aliyun.com\/zabbix/'</span> /etc/yum.repos.d/zabbix.repo
dnf clean all

2. 安装源
dnf install zabbix-proxy-mysql zabbix-sql-scripts zabbix-selinux-policy mysql-server

3. 创建数据库
<span class="hljs-comment"># mysql -uroot -p</span>
password
mysql&gt; create database zabbix_proxy character <span class="hljs-built_in">set</span> utf8mb4 collate utf8mb4_bin;
mysql&gt; create user zabbix@localhost identified by <span class="hljs-string">'alopex'</span>;
mysql&gt; grant all privileges on zabbix_proxy.* to zabbix@localhost;
mysql&gt; <span class="hljs-built_in">set</span> global log_bin_trust_function_creators = 1;
mysql&gt; quit;

4. 导入数据库脚本
cat /usr/share/zabbix-sql-scripts/mysql/proxy.sql | mysql --default-character-set=utf8mb4 -uzabbix -p zabbix_proxy
mysql -uroot -p
password
mysql&gt; <span class="hljs-built_in">set</span> global log_bin_trust_function_creators = 0;
mysql&gt; quit;

5. 配置数据库密码 
&gt; /etc/zabbix/zabbix_proxy.conf
DBPassword=alopex

6. 启动zabbix-proxy
systemctl restart zabbix-proxy
systemctl <span class="hljs-built_in">enable</span> zabbix-proxy</code></pre></div>
<h2 id="工作模式">工作模式</h2>
<blockquote>
<p>与<code>zabbix agent</code>定位类似</p>
</blockquote>
<ul>
<li>主动模式：<code>proxy</code>周期性主动发送数据给<code>server</code>，大幅降低<code>server</code>的压力。（<code>推介使用</code>）</li>
<li>被动模式：<code>server</code>通过发送监控项指令向<code>proxy</code>请求数据</li>
</ul>
<h2 id="主动模式-2">主动模式</h2>
<table>
<thead>
<tr>
<th>zabbix server</th>
<th>zabbix proxy</th>
<th>zabbix agent (被监控主机)</th>
</tr>
</thead>
<tbody>
<tr>
<td>192.168.100.136</td>
<td>192.168.100.34</td>
<td>192.168.100.</td>
</tr>
</tbody>
</table>
<h3 id="proxy文件">proxy文件</h3>
<blockquote>
<p>前端配置后，需要重启proxy</p>
</blockquote>
<div><pre class="hljs"><code>grep -v '^<span class="hljs-comment">#\|^$' /etc/zabbix/zabbix_proxy.conf</span>

<span class="hljs-attr">ProxyMode</span>=<span class="hljs-number">0</span>  <span class="hljs-comment"># 开启主动模式（默认）</span>
<span class="hljs-attr">Server</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">100.136</span> <span class="hljs-comment"># zabbix server IP地址</span>
<span class="hljs-attr">Hostname</span>=zabbix-proxy-active <span class="hljs-comment"># proxy的名称，需和前端配置一致</span>
<span class="hljs-attr">LogFile</span>=/var/log/zabbix/zabbix_proxy.log <span class="hljs-comment"># 日志文件路径</span>
<span class="hljs-attr">LogFileSize</span>=<span class="hljs-number">0</span> 
<span class="hljs-attr">PidFile</span>=/run/zabbix/zabbix_proxy.pid
<span class="hljs-attr">SocketDir</span>=/run/zabbix
<span class="hljs-attr">DBName</span>=zabbix_proxy
<span class="hljs-attr">DBUser</span>=zabbix
<span class="hljs-attr">DBPassword</span>=alopex
<span class="hljs-attr">SNMPTrapperFile</span>=/var/log/snmptrap/snmptrap.log
<span class="hljs-attr">Timeout</span>=<span class="hljs-number">4</span>
<span class="hljs-attr">LogSlowQueries</span>=<span class="hljs-number">3000</span>
<span class="hljs-attr">StatsAllowedIP</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>,<span class="hljs-number">192.168</span>.<span class="hljs-number">100.0</span>/<span class="hljs-number">24</span> <span class="hljs-comment"># 允许接受的agent网段</span></code></pre></div>
<h3 id="agent文件">agent文件</h3>
<div><pre class="hljs"><code>grep -Ev '^<span class="hljs-comment">#|^$' /etc/zabbix/zabbix_agentd.conf </span>

<span class="hljs-attr">PidFile</span>=/run/zabbix/zabbix_agentd.pid
<span class="hljs-attr">LogFile</span>=/var/log/zabbix/zabbix_agentd.log
<span class="hljs-attr">LogFileSize</span>=<span class="hljs-number">0</span>
<span class="hljs-attr">Server</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">100.136</span>,<span class="hljs-number">192.168</span>.<span class="hljs-number">100.34</span>
<span class="hljs-attr">ServerActive</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">100.136</span>,<span class="hljs-number">192.168</span>.<span class="hljs-number">100.34</span>
<span class="hljs-attr">Hostname</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">100.77</span>
<span class="hljs-attr">Timeout</span>=<span class="hljs-number">20</span>
<span class="hljs-attr">Include</span>=/etc/zabbix/zabbix_agentd.d/*.conf</code></pre></div>
<h3 id="前端配置">前端配置</h3>
<p><img src="/_resources/1d12cd7d87524ac4b7f8104ad4fc64ee.png" /><br />
<img src="/_resources/133d7f150a2645f99230cda754e6f579.png" /></p>
<h3 id="验证监控">验证监控</h3>
<p><img src="/_resources/d49284f3965344b99091e45ae67ce508.png" /><br />
<img src="/_resources/a5288214fff5417bb1e506957d811023.png" /></p>
<h2 id="被动模式">被动模式</h2>
<table>
<thead>
<tr>
<th>zabbix server</th>
<th>zabbix proxy</th>
<th>zabbix agent (被监控主机)</th>
</tr>
</thead>
<tbody>
<tr>
<td>192.168.100.136</td>
<td>192.168.100.34</td>
<td>192.168.100.</td>
</tr>
</tbody>
</table>
<h3 id="proxy数据库修改">proxy数据库修改</h3>
<div><pre class="hljs"><code>mysql -uroot

<span class="hljs-comment"># 被动模式需要zabbix server主动连接，数据库不能仅由proxy访问</span>
UPDATE mysql.user
SET Host = <span class="hljs-string">'localhost'</span>
WHERE User = <span class="hljs-string">'zabbix'</span>;

grant all privileges on zabbix_proxy.* to zabbix@<span class="hljs-string">'192.168.100.%'</span>;

select host,user from mysql.user;</code></pre></div>
<h3 id="proxy文件-2">proxy文件</h3>
<div><pre class="hljs"><code>grep -v '^<span class="hljs-comment">#\|^$' /etc/zabbix/zabbix_proxy.conf</span>

<span class="hljs-attr">ProxyMode</span>=<span class="hljs-number">1</span>  <span class="hljs-comment"># 开启被动模式</span>
<span class="hljs-attr">Server</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">100.136</span> <span class="hljs-comment"># zabbix server 主机IP</span>
<span class="hljs-attr">Hostname</span>=zabbix-proxy-passive <span class="hljs-comment"># 代理服务器名称，被动模式不要求和后面Web管理页的agent代理程序名称相同</span>
<span class="hljs-attr">LogFile</span>=/var/log/zabbix/zabbix_proxy.log 
<span class="hljs-attr">LogFileSize</span>=<span class="hljs-number">0</span>
<span class="hljs-attr">PidFile</span>=/run/zabbix/zabbix_proxy.pid
<span class="hljs-attr">SocketDir</span>=/run/zabbix
<span class="hljs-attr">DBHost</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">100.34</span>  <span class="hljs-comment"># 修改为Proxy数据库 IP地址</span>
<span class="hljs-attr">DBName</span>=zabbix_proxy
<span class="hljs-attr">DBUser</span>=zabbix
<span class="hljs-attr">DBPassword</span>=alopex
<span class="hljs-attr">SNMPTrapperFile</span>=/var/log/snmptrap/snmptrap.log
<span class="hljs-attr">Timeout</span>=<span class="hljs-number">4</span>
<span class="hljs-attr">LogSlowQueries</span>=<span class="hljs-number">3000</span>
<span class="hljs-attr">StatsAllowedIP</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>,<span class="hljs-number">192.168</span>.<span class="hljs-number">100.0</span>/<span class="hljs-number">24</span></code></pre></div>
<h3 id="agent文件-2">agent文件</h3>
<div><pre class="hljs"><code>grep -Ev '^<span class="hljs-comment">#|^$' /etc/zabbix/zabbix_agentd.conf </span>

<span class="hljs-attr">PidFile</span>=/run/zabbix/zabbix_agentd.pid
<span class="hljs-attr">LogFile</span>=/var/log/zabbix/zabbix_agentd.log
<span class="hljs-attr">LogFileSize</span>=<span class="hljs-number">0</span>
<span class="hljs-attr">Server</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">100.136</span>,<span class="hljs-number">192.168</span>.<span class="hljs-number">100.34</span>  <span class="hljs-comment"># 设置Proxy代理IP</span>
<span class="hljs-attr">Hostname</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">100.77</span>
<span class="hljs-attr">Timeout</span>=<span class="hljs-number">20</span>
<span class="hljs-attr">Include</span>=/etc/zabbix/zabbix_agentd.d/*.conf</code></pre></div>
<h3 id="前端配置-2">前端配置</h3>
<div><pre class="hljs"><code>sudo grep -Ev <span class="hljs-string">'^#|^$'</span> /etc/zabbix/zabbix_server.conf 
LogFile=/var/<span class="hljs-built_in">log</span>/zabbix/zabbix_server.log
LogFileSize=0
PidFile=/run/zabbix/zabbix_server.pid
SocketDir=/run/zabbix
DBName=zabbix
DBUser=zabbix
DBPassword=alopex
JavaGateway=192.168.100.121
StartJavaPollers=10
SNMPTrapperFile=/var/<span class="hljs-built_in">log</span>/snmptrap/snmptrap.log
Timeout=4
FpingLocation=/usr/bin/fping
Fping6Location=/usr/bin/fping6
LogSlowQueries=3000
StatsAllowedIP=127.0.0.1,192.168.100.0/24  <span class="hljs-comment"># 配置可通信IP地址段</span></code></pre></div>
<p><img src="/_resources/73bc211c0e344e58a1dbd73f5f0028d6.png" /></p>
<h3 id="验证监控-2">验证监控</h3>
<h2 id="参考">参考</h2>
<p><a title="https://www.cnblogs.com/yinzhengjie2020/p/12343765.html" href="https://www.cnblogs.com/yinzhengjie2020/p/12343765.html">zabbix proxy配置实战案例</a></p>
<h1 id="一键zabbix-agent脚本">一键zabbix agent脚本</h1>
<div><pre class="hljs"><code><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># 安装agent</span>
wget https://repo.zabbix.com/zabbix/6.0/ubuntu/pool/main/z/zabbix-release/zabbix-release_6.0-4+ubuntu22.04_all.deb
dpkg -i zabbix-release_6.0-4+ubuntu22.04_all.deb
sed -i <span class="hljs-string">'s!http://repo.zabbix.com!https://mirrors.aliyun.com/zabbix!'</span> /etc/apt/sources.list.d/zabbix.list
apt update
apt install zabbix-agent

<span class="hljs-comment"># 主动被动二选一</span>
<span class="hljs-comment">## 被动模式配置修改</span>
<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -ne 1 ]
<span class="hljs-keyword">then</span>
   <span class="hljs-built_in">echo</span> <span class="hljs-string">"Usage: bash script.sh &lt;zabbix-server&gt;"</span>
   <span class="hljs-built_in">exit</span> -1
<span class="hljs-keyword">fi</span>
ZABBIX=<span class="hljs-variable">${1}</span>
sed -i <span class="hljs-string">"s/^Server=127.0.0.1/Server=<span class="hljs-variable">${ZABBIX}</span>/"</span> /etc/zabbix/zabbix_agentd.conf

<span class="hljs-comment">## 主动模式配置修改</span>
<span class="hljs-comment">#if [ $# -ne 2 ]</span>
<span class="hljs-comment">#then</span>
<span class="hljs-comment">#   echo "Usage: bash script.sh &lt;zabbix-server&gt; &lt;Hostname&gt;"</span>
<span class="hljs-comment">#   exit -1</span>
<span class="hljs-comment">#fi</span>
<span class="hljs-comment">#ZABBIX=${1}</span>
<span class="hljs-comment">#HOSTNAME=${2}</span>
<span class="hljs-comment">## sed -i "s/^Server=127.0.0.1/Server=${ZABBIX}/" /etc/zabbix/zabbix_agentd.conf</span>
<span class="hljs-comment">## sed -i "s/^ServerActive=127.0.0.1/ServerActive=${ZABBIX}/" /etc/zabbix/zabbix_agentd.conf</span>
<span class="hljs-comment">## sed -i "s/^Hostname=.*/Hostname=${HOSTNAME}/" /etc/zabbix/zabbix_agentd.conf</span>

systemctl restart zabbix-agent</code></pre></div>
<h1 id="一键zabbix-api添加zabbix-agent">一键zabbix api添加zabbix agent</h1>
<h2 id="api_create-被动模式">api_create (被动模式)</h2>
<div><pre class="hljs"><code><span class="hljs-meta">#!/bin/bash</span>

HOST=$(hostname -I | awk <span class="hljs-string">'{print $1}'</span>)
ZABBIX_SERVER=<span class="hljs-string">'my_zabbix.com'</span>
nginx_URL=<span class="hljs-string">"http://<span class="hljs-variable">${ZABBIX_SERVER}</span>/api_jsonrpc.php"</span>
apache_URL=<span class="hljs-string">"http://<span class="hljs-variable">${ZABBIX_SERVER}</span>/zabbix/api_jsonrpc.php"</span>

<span class="hljs-comment"># 选择web服务器类型指定URL</span>
URL=<span class="hljs-variable">$nginx_URL</span>

token=$(curl -s -XPOST -H <span class="hljs-string">"Content-Type: application/json-rpc"</span> -d <span class="hljs-string">'
{
"jsonrpc": "2.0",
"method": "user.login",
"params": {
  "user": "Admin",
  "password": "zabbix"
},
"id": 1,
"auth": null
}'</span> <span class="hljs-variable">$URL</span> | cut -d <span class="hljs-string">','</span> -f2 | cut -d <span class="hljs-string">'"'</span> -f4)

curl -s -XPOST -H <span class="hljs-string">"Content-Type: application/json-rpc"</span> -d <span class="hljs-string">'
{
"jsonrpc": "2.0",
"method": "host.create",
"params": {
  "host": "'</span><span class="hljs-variable">$HOST</span><span class="hljs-string">'",
  "name": "'</span>API-<span class="hljs-variable">$HOST</span><span class="hljs-string">'",
  "interfaces": [
    {
      "type": 1,
      "main": 1,
      "useip": 1,
      "ip": "'</span><span class="hljs-variable">$HOST</span><span class="hljs-string">'",
      "dns": "",
      "port": "10050"
    }
  ],
  "groups": [
    {
      "groupid": "2"
    }
  ],
  "templates": [
    {
      "templateid": "10001"
    }
  ]
},
"id": 1,
"auth": "'</span><span class="hljs-variable">$token</span><span class="hljs-string">'"
}'</span> <span class="hljs-variable">$URL</span> | python3 -m json.tool</code></pre></div>
<h2 id="api_create-主动模式">api_create (主动模式)</h2>
<div><pre class="hljs"><code><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$#</span> -ne 1 ]]
<span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">"usage: bash script.sh &lt;HOSTNAME&gt;"</span>
  <span class="hljs-built_in">exit</span> -1
<span class="hljs-keyword">fi</span>

HOST=$(hostname -I | awk <span class="hljs-string">'{print $1}'</span>)
HOSTNAME=<span class="hljs-variable">${1}</span>
ZABBIX_SERVER=<span class="hljs-string">'my_zabbix.com'</span>
nginx_URL=<span class="hljs-string">"http://<span class="hljs-variable">${ZABBIX_SERVER}</span>/api_jsonrpc.php"</span>
apache_URL=<span class="hljs-string">"http://<span class="hljs-variable">${ZABBIX_SERVER}</span>/zabbix/api_jsonrpc.php"</span>

<span class="hljs-comment"># 选择web服务器类型指定URL</span>
URL=<span class="hljs-variable">$nginx_URL</span>

token=$(curl -s -XPOST -H <span class="hljs-string">"Content-Type: application/json-rpc"</span> -d <span class="hljs-string">'
{
"jsonrpc": "2.0",
"method": "user.login",
"params": {
  "user": "Admin",
  "password": "zabbix"
},
"id": 1,
"auth": null
}'</span> <span class="hljs-variable">$URL</span> | cut -d <span class="hljs-string">','</span> -f2 | cut -d <span class="hljs-string">'"'</span> -f4)

curl -s -XPOST -H <span class="hljs-string">"Content-Type: application/json-rpc"</span> -d <span class="hljs-string">'
{
"jsonrpc": "2.0",
"method": "host.create",
"params": {
  "host": "'</span><span class="hljs-variable">$HOSTNAME</span><span class="hljs-string">'",
  "name": "'</span><span class="hljs-variable">$HOST</span><span class="hljs-string">'",
  "interfaces": [
    {
      "type": 1,
      "main": 1,
      "useip": 1,
      "ip": "'</span><span class="hljs-variable">$HOST</span><span class="hljs-string">'",
      "dns": "",
      "port": "10050"
    }
  ],
  "groups": [
    {
      "groupid": "2"
    }
  ],
  "templates": [
    {
      "templateid": "10343"
    }
  ]
},
"id": 1,
"auth": "'</span><span class="hljs-variable">$token</span><span class="hljs-string">'"
}'</span> <span class="hljs-variable">$URL</span> | python3 -m json.tool</code></pre></div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[第一周作业]]></title>
            <guid>1bce478c5dc64adbb0030681a1d8ab08</guid>
            <pubDate>Tue, 02 Apr 2024 03:19:23 GMT</pubDate>
            <content:encoded><![CDATA[<nav class="table-of-contents"><ul><li><a href="#在虚拟机安装tomcat并部署服务并且实现会话共享">在虚拟机安装tomcat并部署服务，并且实现会话共享</a><ul><li><a href="#tomcat安装">tomcat安装</a><ul><li><a href="#包安装">包安装</a></li></ul></li><li><a href="#部署一个简单应用">部署一个简单应用</a></li><li><a href="#会话共享">会话共享</a><ul><li><a href="#session-绑定">session 绑定</a></li><li><a href="#session-复制">session 复制</a></li><li><a href="#session-server">session Server</a><ul><li><a href="#msm-解决方案">MSM 解决方案</a></li></ul></li></ul></li></ul></li><li><a href="#总结jvm内存结构和垃圾回收算法">总结JVM内存结构和垃圾回收算法</a><ul><li><a href="#jvm-内存管理">JVM 内存管理</a><ul><li><a href="#线程私有的内存区域">线程私有的内存区域</a><ul><li><a href="#程序计数器program-counter-register">程序计数器（Program Counter Register）</a></li><li><a href="#虚拟机栈vm-stack">虚拟机栈（VM Stack）</a></li><li><a href="#本地方法栈native-method-stack">本地方法栈（Native Method Stack）</a></li></ul></li><li><a href="#线程共享的内存区域">线程共享的内存区域</a><ul><li><a href="#堆heap">堆（Heap）</a></li><li><a href="#方法区method-area">方法区（Method Area）</a></li></ul></li></ul></li><li><a href="#垃圾回收机制">垃圾回收机制</a><ul><li><a href="#垃圾判断-what">垃圾判断 (what)</a></li><li><a href="#回收方式-how">回收方式 (how)</a><ul><li><a href="#复制算法coping">复制算法（Coping）</a></li></ul></li><li><a href="#标记清除算法mark-sweep">标记清除算法（Mark-Sweep）</a><ul><li><a href="#标记整理算法mark-compact">标记整理算法（Mark-Compact）</a></li><li><a href="#小结">小结</a></li></ul></li><li><a href="#回收思想-why">回收思想 (why)</a></li><li><a href="#垃圾收集器-which">垃圾收集器 (which)</a><ul><li><a href="#分类">分类</a></li><li><a href="#新生代">新生代</a></li><li><a href="#老年代">老年代</a></li><li><a href="#g1收集器">G1收集器</a></li></ul></li><li><a href="#总结表格">总结表格</a></li><li><a href="#回收时间-when">回收时间 (when)</a></li><li><a href="#收集策略-policy">收集策略 (policy)</a></li><li><a href="#yong-gc-minor-gc-的触发">Yong GC / Minor GC 的触发</a><ul><li><a href="#yong-gc-minor-gc-过程">Yong GC / Minor GC 过程</a></li><li><a href="#old-gc-major-gc-full-gc-的触发">Old GC / Major GC / Full GC 的触发</a></li><li><a href="#old-gc-major-gc-过程">Old GC / Major GC 过程</a></li><li><a href="#full-gc-过程">FULL GC 过程</a></li><li><a href="#minor-gc-vs-major-gc">Minor GC vs Major GC</a></li><li><a href="#survivor-区对象晋升位老年代">Survivor 区对象晋升位老年代</a></li><li><a href="#比例关系">比例关系</a></li></ul></li></ul></li></ul></li><li><a href="#总结安装nexus步骤和私有仓库实现">总结安装Nexus步骤和私有仓库实现</a><ul><li><a href="#安装">安装</a></li><li><a href="#运行">运行</a><ul><li><a href="#前台运行">前台运行</a></li><li><a href="#后台运行">后台运行</a></li><li><a href="#关闭运行">关闭运行</a></li></ul></li><li><a href="#配置启动脚本">配置启动脚本</a></li><li><a href="#首次登录">首次登录</a></li><li><a href="#自建apt仓库">自建apt仓库</a></li></ul></li></ul></nav><h1 id="在虚拟机安装tomcat并部署服务并且实现会话共享">在虚拟机安装tomcat并部署服务，并且实现会话共享</h1>
<h2 id="tomcat安装">tomcat安装</h2>
<h3 id="包安装">包安装</h3>
<div><pre class="hljs"><code><span class="hljs-comment"># CentOS / Rocky</span>
    <span class="hljs-comment"># 查询当前tomcat版本 (一般需要epel源)</span>
    yum list |grep tomcat

    <span class="hljs-comment"># 安装tomcat</span>
    yum -y install tomcat tomcat-admin-webapps tomcat-docs-webapp tomcat-webapps

    <span class="hljs-comment"># 开启tomcat</span>
    systemctl <span class="hljs-built_in">enable</span> --now tomcat.service

    <span class="hljs-comment"># 查看状态</span>
    systemctl status tomcat.service
    ss -tulnp
    journalctl -u tomcat.service
    ps aux|grep tomcat

    <span class="hljs-comment"># 验证</span>
    curl 127.0.0.1:8080

<span class="hljs-comment"># debian / ubuntu</span>
    <span class="hljs-comment"># 查询当前tomcat版本</span>
    apt list | grep tomcat

    <span class="hljs-comment"># 安装tomcat (该包名包含主版本号)</span>
    apt update &amp;&amp; apt -y install tomcat9 tomcat9-admin tomcat9- docs tomcat9-examples

    <span class="hljs-comment"># 开启tomcat</span>
    systemctl <span class="hljs-built_in">enable</span> --now tomcat.service

    <span class="hljs-comment"># 查看状态</span>
    systemctl status tomcat.service
    ss -tulnp
    journalctl -u tomcat.service
    ps aux|grep tomcat

    <span class="hljs-comment"># 验证</span>
    curl 127.0.0.1:8080</code></pre></div>
<h2 id="部署一个简单应用">部署一个简单应用</h2>
<ul>
<li>
<p>conf/server.xml</p>
<div><pre class="hljs"><code><span class="hljs-comment">&lt;!-- 使用默认应用路径    --&gt;</span>
<span class="hljs-comment">&lt;!-- alopex.net __&gt; webapps/ROOT	 --&gt;</span>
<span class="hljs-comment">&lt;!-- alopex.net __&gt; webapps/blog	 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"alopex.net"</span> <span class="hljs-attr">appBase</span>=<span class="hljs-string">"webapps"</span>
        <span class="hljs-attr">unpackWAR</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">autoDeploy</span>=<span class="hljs-string">"true"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/blog"</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">"blog"</span> <span class="hljs-attr">reloadable</span>=<span class="hljs-string">"true"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Valve</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="hljs-attr">directory</span>=<span class="hljs-string">"logs"</span>
           <span class="hljs-attr">prefix</span>=<span class="hljs-string">"alopex_access_webapps_log"</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">".txt"</span>
           <span class="hljs-attr">pattern</span>=<span class="hljs-string">"%h %l %u %t <span class="hljs-symbol">&amp;quot;</span>%r<span class="hljs-symbol">&amp;quot;</span> %s %b"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Host</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 访问路径与磁盘路径剥离类似于Nginx的alias   --&gt;</span>
<span class="hljs-comment">&lt;!-- alopex.com __&gt;       /www/alopex	 --&gt;</span>
<span class="hljs-comment">&lt;!-- alopex.com/blog __&gt;  /www/alopex/blog	 --&gt;</span>
<span class="hljs-comment">&lt;!-- alopex.com/blogX __&gt; /xxx/blogx	 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"alopex.com"</span> <span class="hljs-attr">appBase</span>=<span class="hljs-string">"/www/alopex"</span>
        <span class="hljs-attr">unpackWAR</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">autoDeploy</span>=<span class="hljs-string">"true"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">path</span>=<span class="hljs-string">""</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">""</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/blog"</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">"blog"</span> <span class="hljs-attr">reloadable</span>=<span class="hljs-string">"true"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/blogX"</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">"/xxx/blogx"</span> <span class="hljs-attr">reloadable</span>=<span class="hljs-string">"true"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Valve</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="hljs-attr">directory</span>=<span class="hljs-string">"logs"</span>
           <span class="hljs-attr">prefix</span>=<span class="hljs-string">"alopex_access_log"</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">".txt"</span>
           <span class="hljs-attr">pattern</span>=<span class="hljs-string">"%h %l %u %t <span class="hljs-symbol">&amp;quot;</span>%r<span class="hljs-symbol">&amp;quot;</span> %s %b"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Host</span>&gt;</span></code></pre></div>
</li>
<li>
<p>生成文件</p>
<div><pre class="hljs"><code>tree /xxx/ /www/ ../webapps/blog/
/xxx/
└── blogx
    └── index.html
/www/
└── alopex
    ├── blog
    │   └── index.html
    └── index.html
../webapps/blog/
└── index.html
</code></pre></div>
</li>
<li>
<p>修改用户</p>
<blockquote>
<p>chown -R tomcat.tomcat blog/ /www/ /xxx/</p>
</blockquote>
</li>
<li>
<p>修改访问客户端<code>/etc/hosts</code><br />
<a href="https://www.adamsdesk.com/posts/sudo-echo-permission-denied/">Why Does Sudo Echo Fail with Permission Denied?</a></p>
<blockquote>
<p>echo "192.168.100.34 alopex.com alopex.net " | sudo tee -a /etc/hosts</p>
</blockquote>
</li>
<li>
<p>访问</p>
<ul>
<li><a title="http://alopex.net:8080" href="http://alopex.net:8080">http://alopex.net:8080</a> --&gt; /usr/local/apache-tomcat-9.0.87/webapps/ROOT</li>
<li><a title="http://alopex.net:8080/blog/" href="http://alopex.net:8080/blog/">http://alopex.net:8080/blog/</a> --&gt; /usr/local/apache-tomcat-9.0.87/webapps/blog</li>
</ul>
<blockquote></blockquote>
<ul>
<li><a title="http://alopex.com:8080/" href="http://alopex.com:8080/">http://alopex.com:8080/</a> --&gt; /www/alopex</li>
<li><a title="http://alopex.com:8080/blog/" href="http://alopex.com:8080/blog/">http://alopex.com:8080/blog/</a> --&gt; /www/alopex/blog</li>
<li><a title="http://alopex.com:8080/blogX/" href="http://alopex.com:8080/blogX/">http://alopex.com:8080/blogX/</a> --&gt; /xxx/blogx</li>
</ul>
</li>
</ul>
<h2 id="会话共享">会话共享</h2>
<ul>
<li>
<p>准备工作</p>
<ul>
<li>nginx主机 (nginx/1.18.0 )</li>
</ul>
<div><pre class="hljs"><code>sudo apt install nginx</code></pre></div>
<ul>
<li>tomcat服务器 (java/1.8.0_392, tomcat/9.0.31-1ubuntu0.4)</li>
</ul>
<div><pre class="hljs"><code>sudo apt install openjdk-8-jre
sudo apt install tomcat8
mv /var/lib/tomcat9/webapps/ROOT/index.html /var/lib/tomcat9/webapps/ROOT/index.html.bat

vim /var/lib/tomcat9/webapps/ROOT/index.jsp
&lt;%@ page language=<span class="hljs-string">"java"</span> %&gt;
&lt;html&gt;
  &lt;head&gt;&lt;title&gt;TomcatA&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;&lt;font color=<span class="hljs-string">"red"</span>&gt;Tomcat1/2 &lt;/font&gt;&lt;/h1&gt;
    &lt;table align=<span class="hljs-string">"centre"</span> border=<span class="hljs-string">"1"</span>&gt;
      &lt;tr&gt;
        &lt;td&gt;Session ID&lt;/td&gt;
    &lt;% session.setAttribute(<span class="hljs-string">"abc"</span>,<span class="hljs-string">"abc"</span>); %&gt;
        &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;Created on&lt;/td&gt;
        &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt;
     &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;	

chown -R tomcat.tomcat /var/lib/tomcat9/webapps/ROOT</code></pre></div>
</li>
</ul>
<h3 id="session-绑定">session 绑定</h3>
<blockquote>
<p>特点：简单容实现<br />
缺点：如果目标服务器故障后，如果没有做sessoin持久化<br />
实际应用：实际生产很少选择该方式</p>
</blockquote>
<ul>
<li>
<p>nginx主机</p>
<div><pre class="hljs"><code>vim /etc/nginx/conf.d/tomcat.conf
upstream tomcat-server{
  <span class="hljs-comment"># ip_hash; # 对IP的前24位进行哈希绑定</span>
  <span class="hljs-comment"># hash $remote_addr consistent; # 根据客户端IP的全部位</span>
  <span class="hljs-comment"># hash $cookie_jsessionid consistent; # 通过cookie进行绑定，这样更有助于对主机区分而不是网段</span>
                                        <span class="hljs-comment"># (cookie即使是大写，这里也需要转为小写)</span>
  
  <span class="hljs-comment"># consistent 算法选项可以确保当后端服务器的数量发生变化时，仅有一小部分请求需要重新分配到其他服务器</span>
  <span class="hljs-comment"># 这对于维护会话的连续性和减少因服务器变动而导致的缓存失效非常有用。</span>
  server 192.168.100.121:8080;
  server 192.168.100.122:8080;
}

server {
  listen 192.168.100.120:80;
  location ~* \.(jsp|<span class="hljs-keyword">do</span>)$ {
    proxy_pass http://tomcat-server;
  }
}

systemctl restart nginx.service</code></pre></div>
</li>
<li>
<p>tomcat主机</p>
<div><pre class="hljs"><code>systemctl restart tomcat9.service</code></pre></div>
</li>
<li>
<p>测试</p>
<div><pre class="hljs"><code><span class="hljs-comment"># 浏览器测试</span>
http://192.168.100.120/index.jsp

<span class="hljs-comment"># curl测试</span>
curl http://192.168.100.120/index.jsp -c /tmp/cookie.txt
curl http://192.168.100.120/index.jsp -b /tmp/cookie.txt</code></pre></div>
</li>
</ul>
<h3 id="session-复制">session 复制</h3>
<blockquote>
<p>优点：Tomcat自己的提供的多播集群，通过多播将任何一台的session同步到其它节点；tomcat官方解决方案(建议tomcat<code>数量在4个节点之内</code>)<br />
缺点：Tomcat的同步节点不宜过多，互相即时通信同步session需要<code>大带宽</code>；每一台都拥有<code>全部session</code>，<code>内存损耗太多</code></p>
</blockquote>
<ul>
<li>
<p>nginx服务器</p>
<div><pre class="hljs"><code>vim /etc/nginx/conf.d/tomcat.conf
upstream tomcat-server{
  <span class="hljs-comment"># 轮循算法</span>
  server 192.168.100.121:8080;
  server 192.168.100.122:8080;
}

server {
  listen 192.168.100.120:80;
  location ~* \.(jsp|<span class="hljs-keyword">do</span>)$ {
    proxy_pass http://tomcat-server;
  }
}

systemctl restart nginx.service</code></pre></div>
</li>
<li>
<p>tomcat服务器</p>
<ul>
<li>tomcat9 参考<a title="https://tomcat.apache.org/tomcat-9.0-doc/cluster-howto.html" href="https://tomcat.apache.org/tomcat-9.0-doc/cluster-howto.html">文档</a></li>
<li><code>tomcat9</code> 搭配 <code>java11</code> <code>无法实现session同步</code></li>
<li>conf/server.xml
<ul>
<li><code>address=228.0.0.4</code>: 使用的是组播地址（223.0.0.0 - 239.0.0.0）</li>
<li><code>port=45564</code>: 组播udp端口</li>
<li><code>frequency=500</code>: 500ms 发送一次</li>
<li><code>dropTime=3000</code>: 故障阀值为3秒</li>
<li><code>address="auto"</code>: 监听地址,此项建议修改为当前主机的IP（<code>不支持0.0.0.0</code>），如果不修改可能会导致服务无法启动</li>
<li><code>port=4000</code>: 监听端口</li>
<li><code>autoBind=100</code>: 如果端口出现冲突，自动绑定端口范围<code>4000-4100</code></li>
<li><code>SelectorTime=5000</code>: 自动绑定超时时常<code>5s</code></li>
</ul>
<div><pre class="hljs"><code><span class="hljs-comment">&lt;!-- 在Engine层级添加  --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Cluster</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.ha.tcp.SimpleTcpCluster"</span>
             <span class="hljs-attr">channelSendOptions</span>=<span class="hljs-string">"8"</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">Manager</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.ha.session.DeltaManager"</span>
               <span class="hljs-attr">expireSessionsOnShutdown</span>=<span class="hljs-string">"false"</span>
               <span class="hljs-attr">notifyListenersOnReplication</span>=<span class="hljs-string">"true"</span>/&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">Channel</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.tribes.group.GroupChannel"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Membership</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.tribes.membership.McastService"</span>
                    <span class="hljs-attr">address</span>=<span class="hljs-string">"228.0.0.4"</span>
                    <span class="hljs-attr">port</span>=<span class="hljs-string">"45564"</span>
                    <span class="hljs-attr">frequency</span>=<span class="hljs-string">"500"</span>
                    <span class="hljs-attr">dropTime</span>=<span class="hljs-string">"3000"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Receiver</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.tribes.transport.nio.NioReceiver"</span>
                  <span class="hljs-attr">address</span>=<span class="hljs-string">"auto"</span>
                  <span class="hljs-attr">port</span>=<span class="hljs-string">"4000"</span>
                  <span class="hljs-attr">autoBind</span>=<span class="hljs-string">"100"</span>
                  <span class="hljs-attr">selectorTimeout</span>=<span class="hljs-string">"5000"</span>
                  <span class="hljs-attr">maxThreads</span>=<span class="hljs-string">"6"</span>/&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">Sender</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.tribes.transport.ReplicationTransmitter"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Transport</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.tribes.transport.nio.PooledParallelSender"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">Sender</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Interceptor</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.tribes.group.interceptors.TcpFailureDetector"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Interceptor</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor"</span>/&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Channel</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">Valve</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.ha.tcp.ReplicationValve"</span>
             <span class="hljs-attr">filter</span>=<span class="hljs-string">""</span>/&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Valve</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.ha.session.JvmRouteBinderValve"</span>/&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">Deployer</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.ha.deploy.FarmWarDeployer"</span>
                <span class="hljs-attr">tempDir</span>=<span class="hljs-string">"/tmp/war-temp/"</span>
                <span class="hljs-attr">deployDir</span>=<span class="hljs-string">"/tmp/war-deploy/"</span>
                <span class="hljs-attr">watchDir</span>=<span class="hljs-string">"/tmp/war-listen/"</span>
                <span class="hljs-attr">watchEnabled</span>=<span class="hljs-string">"false"</span>/&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">ClusterListener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.ha.session.ClusterSessionListener"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Cluster</span>&gt;</span></code></pre></div>
</li>
<li>webapps/ROOT/WEB-INFO/web.xml (<code>Make sure your web.xml has the &lt;distributable/&gt; element</code>)<div><pre class="hljs"><code><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://xmlns.jcp.org/xml/ns/javaee"</span>
  <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>
  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span>
  <span class="hljs-attr">version</span>=<span class="hljs-string">"4.0"</span>
  <span class="hljs-attr">metadata-complete</span>=<span class="hljs-string">"true"</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Welcome to Tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>
     Welcome to Tomcat
  <span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 添加此行 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">distributable</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span></code></pre></div>
</li>
</ul>
</li>
</ul>
<h3 id="session-server">session Server</h3>
<h4 id="msm-解决方案">MSM 解决方案</h4>
<blockquote>
<p>当前MSM<code>不支持 tomcat 10</code>版本<br />
(memcached session manager) 提供将Tomcat的session保持到memcached或Redis的程序，可以实现高可用</p>
</blockquote>
<ul>
<li>
<p><a title="https://github.com/magro/memcached-session-manager" href="https://github.com/magro/memcached-session-manager">项目连接</a></p>
</li>
<li>
<p>支持Tomcat的 6.x、7.x、8.x、9.x</p>
<ul>
<li>memcached-session-manager-2.3.2.jar</li>
<li>memcached-session-manager-tc8-2.3.2.jar</li>
</ul>
</li>
<li>
<p>Session数据的序列化、反序列化类</p>
<ul>
<li>官方推荐kyro</li>
<li>在webapp中WEB-INF/lib/下</li>
</ul>
</li>
<li>
<p>驱动类</p>
<ul>
<li>memcached(spymemcached.jar)</li>
<li>Redis(jedis.jar)</li>
</ul>
</li>
<li>
<p>配置</p>
</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-comment"># 在 $CATALINA_HOME/lib/ 目录下放入如需包</span>
kryo-3.0.3.jar
asm-5.2.jar
objenesis-2.6.jar
reflectasm-1.11.9.jar
minlog-1.3.1.jar
kryo-serializers-0.45.jar
msm-kryo-serializer-2.3.2.jar
memcached-session-manager-tc8-2.3.2.jar
spymemcached-2.12.3.jar
memcached-session-manager-2.3.2.jar

<span class="hljs-comment"># sticky 模式</span>
&gt; 即前端tomcat和后端memcached有关联(粘性)关系

<span class="hljs-comment"># 粘性一般为交叉粘性，因此主机n1,对应failoverNodes为n1;同理主机n2,对应failoverNodes为n2</span>
<span class="hljs-comment"># memcachedNodes="n1:host1.yourdomain.com:11211,n2:host2.yourdomain.com:11211"</span>
<span class="hljs-comment"># memcached的节点: n1、n2只是别名，可以重新命名。</span>
<span class="hljs-comment"># failoverNodes 为故障转移节点，n1是备用节点，n2是主存储节点。另一台Tomcat将此处的n1改为n2，</span>

<span class="hljs-comment"># 修改$CATALINA_HOME/conf/context.xml</span>
<span class="hljs-comment"># 其主节点是n1，备用节点是n2。</span>
    <span class="hljs-comment"># n1 (192.168.100.121) 配置 </span>
    &lt;Context&gt;
    &lt;Manager className=<span class="hljs-string">"de.javakaffee.web.msm.MemcachedBackupSessionManager"</span>
             memcachedNodes=<span class="hljs-string">"n1:192.168.100.121:11211,n2:192.168.100.122:11211"</span>
             failoverNodes=<span class="hljs-string">"n1"</span>
             requestUriIgnorePattern=<span class="hljs-string">".*\.(ico|png|gif|jpg|css|js)$"</span>
             transcoderFactoryClass=<span class="hljs-string">"de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory"</span>/&gt;
    &lt;/Context&gt;
    <span class="hljs-comment"># n2 (192.168.100.122) 配置</span>
    &lt;Context&gt;
    &lt;Manager className=<span class="hljs-string">"de.javakaffee.web.msm.MemcachedBackupSessionManager"</span>
             memcachedNodes=<span class="hljs-string">"n1:192.168.100.121:11211,n2:192.168.100.122:11211"</span>
             failoverNodes=<span class="hljs-string">"n2"</span>
             requestUriIgnorePattern=<span class="hljs-string">".*\.(ico|png|gif|jpg|css|js)$"</span>
             transcoderFactoryClass=<span class="hljs-string">"de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory"</span>/&gt;
    &lt;/Context&gt;


    <span class="hljs-comment"># 查看启动日志</span>
    journal -u tomcat9.service
    Mar 19 13:19:52 n2 tomcat9[86253]: --------
    Mar 19 13:19:52 n2 tomcat9[86253]: -  finished initialization:
    Mar 19 13:19:52 n2 tomcat9[86253]: - sticky: <span class="hljs-literal">true</span>
    Mar 19 13:19:52 n2 tomcat9[86253]: - operation timeout: 1000
    Mar 19 13:19:52 n2 tomcat9[86253]: - node ids: [n1]
    Mar 19 13:19:52 n2 tomcat9[86253]: - failover node ids: [n2]
    Mar 19 13:19:52 n2 tomcat9[86253]: - storage key prefix: null
    Mar 19 13:19:52 n2 tomcat9[86253]: - locking mode: null (expiration: 5s)
    Mar 19 13:19:52 n2 tomcat9[86253]: --------</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-comment"># non-sticky 模式</span>
&gt; 即前端tomcat和后端memcached无关联(无粘性)关系，从msm 1.4.0之后版本开始支持non-sticky模式。

<span class="hljs-comment"># 在 $CATALINA_HOME/lib/ 目录下放入如需包</span>
kryo-3.0.3.jar
asm-5.2.jar
objenesis-2.6.jar
reflectasm-1.11.9.jar
minlog-1.3.1.jar
kryo-serializers-0.45.jar
msm-kryo-serializer-2.3.2.jar
memcached-session-manager-tc8-2.3.2.jar
spymemcached-2.12.3.jar
memcached-session-manager-2.3.2.jar

    <span class="hljs-comment"># 修改$CATALINA_HOME/conf/context.xml</span>
    <span class="hljs-comment"># n1 (192.168.100.121) 配置</span>
    &lt;Context&gt;
    &lt;Manager className=<span class="hljs-string">"de.javakaffee.web.msm.MemcachedBackupSessionManager"</span>
             memcachedNodes=<span class="hljs-string">"n1:192.168.100.121:11211,n2:192.168.100.122:11211"</span>
             sticky=<span class="hljs-string">"false"</span>
             requestUriIgnorePattern=<span class="hljs-string">".*\.(ico|png|gif|jpg|css|js)$"</span>
             transcoderFactoryClass=<span class="hljs-string">"de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory"</span>/&gt;
    &lt;/Context&gt;</code></pre></div>
<ul>
<li>检查memcached脚本 (配置完成后测试)
<ul>
<li><code>sudo apt install python3-pip &amp;&amp; pip3 install python-memcached</code></li>
<li><a>显示memcache内容</a></li>
</ul>
</li>
</ul>
<h1 id="总结jvm内存结构和垃圾回收算法">总结JVM内存结构和垃圾回收算法</h1>
<h2 id="jvm-内存管理">JVM 内存管理</h2>
<p><img src="/_resources/556a3219e39543ca97d38494668252ac.png" /></p>
<h3 id="线程私有的内存区域">线程私有的内存区域</h3>
<h4 id="程序计数器program-counter-register">程序计数器（Program Counter Register）</h4>
<p>程序计数器是一块较小的内存空间（可能位于cpu的寄存器，有待确认），可以看做是当前字节码指令执行的行号指示器，记录了当前正在执行的虚拟机字节码指令地址。每个线程都有各自独立的程序计数器，注意如果正在执行的是 Native方法，则程序计数器为空（Undifined），并且 JVM 规范中并<code>没有对程序计数器定义 OutOfMemoryError 异常</code>。</p>
<h4 id="虚拟机栈vm-stack">虚拟机栈（VM Stack）</h4>
<p>虚拟机栈也是线程私有的，它描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈和出栈的过程。</p>
<p>虚拟机栈帧中，<code>局部变量表</code>是比较为人所熟知的，也就是平常所说的“栈”，局部变量表所需的内存空间在编译期间分配完成，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法<code>运行期间</code>不会改变局部变量表的大小。</p>
<p>虚拟机栈有两种异常情况：</p>
<ol>
<li><code>StackOverflowError</code>：线程请求的栈深度大于虚拟机所允许的深度，特别是方法的递归调用时</li>
<li><code>OutOfMemoryError</code>：虚拟机栈无法满足线程所申请的空间需求，即使经过动态扩展仍然无法满足时抛出</li>
</ol>
<h4 id="本地方法栈native-method-stack">本地方法栈（Native Method Stack）</h4>
<p>本地方法栈与虚拟机栈相似，不过服务于本地方法，有些虚拟机将这两个区域合二为一。本地方法栈中抛出异常的情况与虚拟机栈相同。</p>
<h3 id="线程共享的内存区域">线程共享的内存区域</h3>
<h4 id="堆heap">堆（Heap）</h4>
<p>通常来说，堆是Java虚拟机管理的内存中<code>最大的一块</code>，被所有线程共享，在虚拟机启动时创建，堆的作用就是存储对象实例。</p>
<p>堆也是垃圾收集器所管理的主要区域，因此很多时候也被称作<code>GC堆</code>。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，因此堆还可以被细分为：<code>新生代</code>和<code>老年代</code>。再继续细分可以分为：<code>Eden空间</code>、<code>From Survivor空间</code>、<code>To Survivor空间</code>等，从内存分配的角度来看，线程共享的堆中还可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。</p>
<p>堆可以是<code>物理上不连续的空间</code>，只要<code>逻辑上是连续的</code>即可，-Xmx和-Xms参数可以控制堆的最大和最小值。</p>
<p>堆的空间大小不满足时将抛出<code>OutOfMemoryError异常</code>。</p>
<h4 id="方法区method-area">方法区（Method Area）</h4>
<p>用于存储已被虚拟机加载的<code>类信息</code>、<code>常量</code>、<code>静态变量</code>、<code>JIT编译后的代码</code>等数据。Java虚拟机规范将方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做<code>Non-Heap</code>（非堆）。</p>
<p>方法区同样会抛出<code>OutOfMemoryError异常</code>。</p>
<p>在方法区中有一部分区域用来存储编译期产生的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。这里需要说明一点，常量并不是只能在编译期产生，运行期间也会产生新的常量并被发在常量池中，如 String 类的 intern() 方法。</p>
<h2 id="垃圾回收机制">垃圾回收机制</h2>
<p>JVM 管理的内存中，线程私有的<code>虚拟机栈</code>、<code>本地方法栈</code>以及<code>程序计数器</code>都是随着线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出有条不紊的进行入栈和出栈。<br />
这部分内存区域随着线程结束或者方法退出自然的就被释放回收了，因此这部分不需要过多考虑回收问题。而 <code>Java 堆</code>和<code>方法区</code>则不一样，这部分内存的分配和回收都是动态的。垃圾收集器关注的区域主要指的是这部分内存。</p>
<h3 id="垃圾判断-what">垃圾判断 (what)</h3>
<blockquote>
<p>GC 在垃圾回收的时候首先需要判断哪些对象时仍在使用，哪些是已经不再使用了</p>
</blockquote>
<ul>
<li><code>引用计数法</code>
<ul>
<li>给对象添加一个引用计数器，每当有一个地方引用计数器就加 1，引用失效时计数器就减 1</li>
<li>因此哪些计数器为 0 的对象都是不再被引用需要回收的对象</li>
<li>优点: 实现简单、效率也高</li>
<li>缺点: 无法解决对象之间相互引用的情况 (相互引用成一个整体，但并无其他对象对其调用)</li>
</ul>
</li>
<li><code>达性分析法</code> (HotSpot 默认)
<ul>
<li>通过一系列称为 <code>GC Roots</code> 的对象作为起点开始向下进行搜索，搜索走过的路径叫做<code>引用链</code></li>
<li>如果一个对象<code>没有任何引用链与其相连</code>时说明该对象不可达，即不可能再被使用到</li>
<li>可作为 <code>GC Roots</code> 的对象
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>本地方法栈中 Native 方法引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="回收方式-how">回收方式 (how)</h3>
<h4 id="复制算法coping">复制算法（Coping）</h4>
<p>这种算法将可用内存按照容量划分为大小相等的两部分，每次只使用其中一半，当这一半使用完了就将其中还存活的对象复制到另一块内存上，然后对这一块内存进行回收，循环往复。优点是<code>实现简单、运行高效</code>。缺点就是可用<code>内存缩小到了原来的一半</code>，这个代价稍微有点高！</p>
<p>这种算法主要被用来回收新生代，因为新生代中的对象百分之九十八都是“朝生夕死”，也就是说大部分内存都会被回收掉，那就没有必要按照 1:1 的比例划分内存空间，而是将内存分为较大的一块 <code>Eden</code> 空间和两块较小的 <code>Survivor</code> 空间。每次使用 <code>Eden</code> 和其中一块 <code>Survivor</code> 区（from），当回收时将其中的存活对象复制到另外一块 <code>Survivor</code> 区，把 <code>Eden</code> 和刚才用过的 <code>Survivor</code> 区清理掉。<code>HotSpot</code> 虚拟机默认的 <code>Eden</code> 和 <code>Survivor</code> 内存比例是 <code>8:1</code>，也就是说每次新生代的可用空间为整个新生代容量的 90%，这样内存的利用率很高，一定程度上避免了上面提到的可用内存折半的缺点。但是我们并没有办法保证每次回收都只有不到 10% 的对象存活（因为存活的对象会被复制到 survivor to 区，这部分只占了 10%），这样就有可能出现 <code>Survivor</code> 内存不够用，需要依赖其它内存（老年代）进行分配担保。<br />
显然在<code>对象存活率较高</code>的情况下这种算法效率就会降低。</p>
<h3 id="标记清除算法mark-sweep">标记清除算法（Mark-Sweep）</h3>
<p>这时最基础的收集算法，分为 “标记” 和“清除”两个阶段：首先按照上面介绍的方法标记出需要回收的对象，标记完成后统一对被标记的对象内存进行回收。显然这种方式会导致<code>产生大量不连续的内存碎片</code>，从而导致后面再需要分配较大对象时<code>无法找到足够的连续内存</code>，从而提前触发另一次垃圾收集。</p>
<h4 id="标记整理算法mark-compact">标记整理算法（Mark-Compact）</h4>
<p>老年代由于存活率比较高（想想为什么），因此并不适合上面提到的复制算法，针对其特点，“<code>标记 - 整理</code>”的算法被提出来。其标记过程与 “<code>标记 - 清除</code>” 算法的过程一样，但后续并不是直接对标记对象进行清理，而是让存活的对象都向一端移动，然后直接清理掉边界以外的区域。</p>
<h4 id="小结">小结</h4>
<p>当代虚拟机都采用 “分代收集” 的思想，一般根据对象存活周期将 Java 堆分为<code>新生代</code>和<code>老年代</code>，分别根据其特点选择相应的收集算法：<code>新生代对象</code>存活率低，则采用 <code>复制算法</code> 只需要对极少比例的存活对象进行复制即可完成收集；而<code>老年代</code>因为存活率高，没有额外空间对其进行分配担保，就必须使用 “<code>标记 - 清理</code>”或者 “<code>标记 - 整理</code>” 算法 来回收。</p>
<h3 id="回收思想-why">回收思想 (why)</h3>
<blockquote>
<p>对任何 “活” 的对象，一定能最终追溯到其存活在<code>堆栈</code>或<code>静态存储区</code>中的引用。<br />
基于此从<code>堆栈</code>和<code>静态存储区</code>开始遍历所有的引用，就能找到所有 “活” 的对象，对这些对象进行标记，将其余的对象回收。</p>
</blockquote>
<ul>
<li>实现方式
<ul>
<li><code>停止 - 复制模式</code> (对应大空间，回收空间连续)
<ul>
<li>先暂停程序运行，将所有活得对象从当前堆复制到另一个堆，没有复制的对象都当作垃圾回收，复制到新堆时对象会被一个挨着一个整齐的排列，这样便可以按照前面说的移动 “堆指针” 的方式直接分配新空间了。当然这种 “复制移动” 式的回收方法效率较低，通常做法是按需从堆中分配几块较大的内存，复制动作发生在这几块<code>较大的内存之间</code>。</li>
</ul>
</li>
<li><code>标记 - 清扫模式</code> (对应小空间，回收空间不连续)
<ul>
<li>前一种 “停止 - 复制” 模式在垃圾较少的情况下效率仍然很低下，因为这时大量的复制行为其实没有必要，于是另一种新的方法。遍历所有引用进而<code>找到所有存活的对象</code>并对其标记，标记完成以后将<code>没有标记的对象清理</code>，这个过程中并不做任何复制。当然这样的话剩下的堆<code>空间并不是连续的</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="垃圾收集器-which">垃圾收集器 (which)</h3>
<ul>
<li>串行垃圾回收器：一个GC线程完成回收工作
<ul>
<li><img src="/_resources/7e90ff860cb4420dbfc1a76fadc6109e.png" /></li>
</ul>
</li>
<li>并行垃圾回收器：多个GC线程同时一起完成回收工作，充分利用CPU资源
<ul>
<li><img src="/_resources/e7655cc5a99b4991a9353ca648c309b6.png" /></li>
</ul>
</li>
<li>并行和并发
<ul>
<li><code>并行</code>（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li><code>并发</code>（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。</li>
</ul>
</li>
<li>吞吐量（Throughput）
<ul>
<li>吞吐量就是<code>CPU用于运行用户代码的时间与CPU总消耗时间的比值</code></li>
<li>即: 吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。</li>
<li>假设虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</li>
</ul>
</li>
</ul>
<h4 id="分类">分类</h4>
<p><img src="/_resources/fca2e5d8870e4a59acef34905d67aff9.png" /></p>
<blockquote>
<p><code>JVM 1.8</code> 默认的垃圾回收器：<code> Parallel Scavenge</code> + <code>ParallelOld</code>,所以大多数都是针对此进行调优</p>
</blockquote>
<h4 id="新生代">新生代</h4>
<ul>
<li>Serial收集器
<ul>
<li>最基本、发展历史最悠久的收集器，它是采用复制算法的新生代收集器，曾经（<code>JDK 1.3.1之前</code>）是虚拟机新生代收集的唯一选择。</li>
<li>一个单线程收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直至Serial收集器收集结束为止（“Stop The World”）</li>
<li>这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说是<code>难以接受</code>的。</li>
<li>Serial收集器对于运行在Client模式下的虚拟机来说是一个很不错的选择。</li>
<li><img src="/_resources/9b6426243ef144ddbb74a7c60860ff9f.png" /></li>
</ul>
</li>
<li>ParNew 收集器
<ul>
<li>Serial收集器的<code>多线程版本</code>，它也是一个新生代收集器。除了使用多线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同，两者共用了相当多的代码。</li>
<li>ParNew 收集器在<code>单CPU</code>的环境中绝对不会有比Serial收集器有更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越。</li>
<li><img src="/_resources/e4102632ac8d4eb59c5f0cfc2d5e2a04.png" /></li>
</ul>
</li>
<li>Parallel Scavenge 收集器
<ul>
<li>个并行的多线程新生代收集器，它也使用复制算法。Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个<code>可控制的吞吐量</code>（Throughput）。</li>
<li>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而<code>高吞吐量则可以高效率地利用CPU时间</code>，<code>尽快完成程序的运算任务</code>，主要适合在后台运算而<code>不需要太多交互的任务</code>。</li>
</ul>
</li>
</ul>
<h4 id="老年代">老年代</h4>
<ul>
<li>Serial Old收集器
<ul>
<li>Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”（Mark-Compact）算法。 此收集器的主要意义也是在于给<code>Client模式</code>下的虚拟机使用。</li>
<li><img src="/_resources/238bbb5df7274354b8c630ffe6f7fa88.png" /></li>
</ul>
</li>
<li>Parallel Old收集器
<ul>
<li>是<code>Parallel Scavenge</code>收集器的老年代版本，使用多线程和“标记-整理”算法，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。</li>
<li><img src="/_resources/7b43fbc61461486ab107e1dc5010e27a.png" /></li>
</ul>
</li>
<li>CMS收集器
<ul>
<li>以获取<code>最短回收停顿时间</code>为目标的收集器，它非常符合那些集中在互联网站或者<code>B/S</code>系统的服务端上的Java应用</li>
<li>CMS收集器工作的整个流程分为以下4个步骤：
<ul>
<li><code>初始标记</code>（CMS initial mark）：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。</li>
<li><code>并发标记</code>（CMS concurrent mark）：进行GC Roots Tracing的过程，在整个过程中耗时最长。</li>
<li><code>重新标记</code>（CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。</li>
<li><code>并发清除</code>（CMS concurrent sweep）</li>
</ul>
</li>
<li>由于整个过程中耗时最长的<code>并发标记</code>和<code>并发清除</code>过程收集器线程都可以与用户线程一起工作。所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</li>
<li><img src="/_resources/be90f86dcfd3447d8a08220be5a81cc2.png" /></li>
</ul>
</li>
</ul>
<h4 id="g1收集器">G1收集器</h4>
<blockquote>
<p>收集器是当今收集器技术发展最前沿的成果之一，它是一款面向<code>服务端</code>应用的垃圾收集器<br />
HotSpot开发团队赋予它的使命是（在比较长期的）未来可以<code>替换掉</code>JDK 1.5中发布的<code>CMS</code>收集器。<br />
<code>并行与并发</code> G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</p>
<p><code>分代收集</code> 与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。</p>
<p><code>空间整合</code> G1从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</p>
<p><code>可预测的停顿</code> 这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了</p>
</blockquote>
<ul>
<li><img src="/_resources/9152055cb6694bbba1afccc17d525ee0.png" /></li>
</ul>
<h3 id="总结表格">总结表格</h3>
<p><img src="/_resources/af2f453bd203428f8299e731fb0a15d3.png" /></p>
<h3 id="回收时间-when">回收时间 (when)</h3>
<ul>
<li><code>Partial GC</code>(局部 GC): 并不收集整个 <code>GC</code> 堆的模式
<ul>
<li><code>Young GC</code>: 只收集 <code>young gen</code> 的 <code>GC</code>，<code>Young GC</code> 还有种说法就叫做 "<code>Minor GC</code>"</li>
<li><code>Old GC</code>: 只收集<code>old gen</code>的<code>GC</code>。只有垃圾收集器<code>CMS</code>的 <code>concurrent collection</code> 是这个模式</li>
<li><code>Mixed GC</code>: 收集整个<code>young gen</code> 以及<code>部分old gen</code>的GC。只有垃圾收集器 <code>G1</code>有这个模式</li>
</ul>
</li>
<li><code>Full GC</code>: 收集整个堆，包括 <code>新生代</code>，<code>老年代</code>，<code>永久代</code>(在 JDK 1.8及以后，永久代被移除，换为<code>metaspace</code> 元空间)等所有部分的模式</li>
</ul>
<h3 id="收集策略-policy">收集策略 (policy)</h3>
<p><img src="/_resources/2c642b3ddd014c90867f6dbdf6f722e2.png" /></p>
<h3 id="yong-gc-minor-gc-的触发">Yong GC / Minor GC 的触发</h3>
<blockquote>
<p>当 <code>Eden</code> 区的空间耗尽时 Java 虚拟机便会触发一次 <code>Minor GC</code> 来收集新生代的垃圾<br />
存活下来的对象，则会被送到 <code>Survivor</code> 区<br />
在进行Yong GC时，通常会使用一种称为"<code>Stop-the-World</code>"的方式来暂停应用程序的执行。</p>
</blockquote>
<h4 id="yong-gc-minor-gc-过程">Yong GC / Minor GC 过程</h4>
<blockquote>
<p>当发生 <code>Minor GC</code> 时，<code>Eden</code> 区和 <code>from</code> 指向的 <code>Survivor</code> 区中的存活对象会被复制(此处采用<code>标记复制</code>算法)到 <code>to</code> 指向的 <code>Survivor</code> 区中<br />
然后交换 <code>from</code> 和 <code>to</code> 指针，以保证下一次 <code>Minor GC</code> 时，<code>to</code> 指向的 <code>Survivor</code> 区还是空的。<br />
<code>from</code> 与 <code>to</code> 只是两个指针，它们变动的，<code>to</code> 指针指向的 <code>Survivor</code> 区是空的。</p>
</blockquote>
<h4 id="old-gc-major-gc-full-gc-的触发">Old GC / Major GC / Full GC 的触发</h4>
<ul>
<li>显式的调用 <code>System.gc()</code>
<ul>
<li>应<code>避免</code>在代码中显式调用此方法，让虚拟机自己去管理它的内存</li>
</ul>
</li>
<li><code>serial GC</code> 中
<ul>
<li>老年代内存剩余已经小于之前年轻代晋升老年代的平均大小</li>
</ul>
</li>
<li><code>CMS</code> 等并发收集器中
<ul>
<li>每隔一段时间检查一下老年代内存的使用量，超过一定比例时进行 <code>Full GC</code> 回收</li>
</ul>
</li>
</ul>
<h4 id="old-gc-major-gc-过程">Old GC / Major GC 过程</h4>
<blockquote>
<p>进行<code>Major GC</code>（大型垃圾回收）时，主要是针对Java堆中的<code>老年代</code>进行回收<br />
首先会<code>标记老年代中的存活对象</code>，然后<code>清理未被标记的对象</code>，释放它们所占用的内存空间。<br />
可能会导致应用<code>程序的停顿</code>，因为在执行垃圾回收时需要暂停应用程序的执行</p>
</blockquote>
<h4 id="full-gc-过程">FULL GC 过程</h4>
<blockquote>
<p>对整个Java堆进行垃圾回收的过程</p>
<ol>
<li>暂停应用程序：为了执行FULL GC，垃圾回收器会暂停应用程序的执行。这个停顿时间的长短取决于具体的垃圾收集器和应用程序的大小。</li>
<li>年轻代垃圾回收：首先，垃圾回收器会执行年轻代的垃圾回收，类似于Yong GC的过程。它会标记和清理年轻代中的垃圾对象，并将存活对象复制到生存带或老年代中。</li>
<li>生存带垃圾回收：接下来，垃圾回收器会对生存带进行垃圾回收。生存带是年轻代中的两个区域之一，用于存放经过一次年轻代垃圾回收后仍然存活的对象。垃圾回收器会标记和清理生存带中的垃圾对象，并将存活对象复制到另一个生存带或老年代中。</li>
<li>老年代垃圾回收：最后，垃圾回收器会对老年代进行垃圾回收。老年代是存放存活时间较长的对象的区域。垃圾回收器会标记和清理老年代中的垃圾对象，并释放它们所占用的内存空间。</li>
<li>内存整理：在FULL GC过程中，垃圾回收器可能会进行内存整理操作，以减少内存碎片化。它会将存活的对象进行整理，使得内存布局更加紧凑。<br />
恢复应用程序执行：完成FULL GC后，垃圾回收器会恢复应用程序的执行，使其继续运行。</li>
</ol>
</blockquote>
<h4 id="minor-gc-vs-major-gc">Minor GC vs Major GC</h4>
<blockquote>
<p><code>Minor GC</code> 可能会引起<code>短暂的STW</code>暂停。当进行 <code>Minor GC</code> 时，为了确保安全性，JVM 需要在某些特定<br />
的点上暂停所有应用程序的线程，以便更新一些关键的数据结构。<br />
这些暂停通常是非常短暂的，通常在<code>毫秒级别</code>，并且很少对应用程序的性能产生显著影响。</p>
</blockquote>
<blockquote>
<p><code>Major GC</code>的暂停时间通常会比<code>Minor GC</code>的暂停<code>时间更长</code>，因为老年代的容量通常比年轻代大得多。<br />
这意味着在收集和整理大量内存时，需要更多的时间来完成垃圾收集操作。</p>
</blockquote>
<h4 id="survivor-区对象晋升位老年代">Survivor 区对象晋升位老年代</h4>
<blockquote>
<p>JVM 会记录 <code>Survivor</code> 区中的对象在 <code>from</code> 和 <code>to</code> 之间一共被来回复制的次数<br />
一个对象被复制的次数为 <code>15</code> （参数 <code>-XX:+MaxTenuringThreshold</code>），该对象将被晋升为至老年代<br />
OR<br />
单个 <code>Survivor</code> 区已经被占用了 50%（参数: <code>-XX:TargetSurvivorRatio</code>）<br />
复制次数较高的对象也会被晋升至老年代</p>
</blockquote>
<h4 id="比例关系">比例关系</h4>
<p><img src="/_resources/a1c7c6afb050480f99e1060bef7acf60.png" /><br />
默认JVM试图分配最大内存的总内存的<code>1/4</code>,初始化默认总内存为总内存的<code>1/64</code>,年青代中heap的<code>1/3</code>，老年代占<code>2/3</code></p>
<h1 id="总结安装nexus步骤和私有仓库实现">总结安装Nexus步骤和私有仓库实现</h1>
<h2 id="安装">安装</h2>
<div><pre class="hljs"><code><span class="hljs-comment"># 安装要求</span>
<span class="hljs-comment"># 要求内存8G以上，太小比如4G以下会导致无法启动</span>

<span class="hljs-comment"># 下载 (需要外网)</span>
&gt; https://help.sonatype.com/en/download.html
wget https://download.sonatype.com/nexus/3/nexus-3.66.0-02-unix.tar.gz

<span class="hljs-comment"># 解压</span>
tar -xf nexus-3.66.0-02-unix.tar.gz  -C /usr/<span class="hljs-built_in">local</span>/

<span class="hljs-comment"># 链接文件</span>
ln -s /usr/<span class="hljs-built_in">local</span>/nexus-3.66.0-02/ /usr/<span class="hljs-built_in">local</span>/nexus
ln -s /usr/<span class="hljs-built_in">local</span>/nexus/bin/nexus /usr/bin/

<span class="hljs-comment"># 配置</span>
    <span class="hljs-comment">## 运行用户配置</span>
    vim /usr/<span class="hljs-built_in">local</span>/nexus/bin/nexus
    run_as_user=<span class="hljs-string">"root"</span>

    <span class="hljs-comment">## 运行端口配置</span>
    vim /usr/<span class="hljs-built_in">local</span>/nexus/etc/nexus-default.properties
    application-port=8081
    application-host=0.0.0.0
    nexus-args=<span class="hljs-variable">${jetty.etc}</span>/jetty.xml,<span class="hljs-variable">${jetty.etc}</span>/jetty-http.xml,<span class="hljs-variable">${jetty.etc}</span>/jetty-requestlog.xml
    nexus-context-path=/
    ...
    
    <span class="hljs-comment">## JVM 优化配置</span>
    vim /usr/<span class="hljs-built_in">local</span>/nexus/bin/nexus.vmoptions
    -Xms2703m
    -Xmx2703m
    -XX:MaxDirectMemorySize=2703m
    ...</code></pre></div>
<h2 id="运行">运行</h2>
<h3 id="前台运行">前台运行</h3>
<blockquote>
<p>nexus run</p>
<blockquote>
<p>可以看到运行状态，方便确认启动日志</p>
</blockquote>
</blockquote>
<h3 id="后台运行">后台运行</h3>
<blockquote>
<p>nexus start</p>
</blockquote>
<h3 id="关闭运行">关闭运行</h3>
<blockquote>
<p>nexus stop<br />
<img src="/_resources/0221ea55b29e4e1387aba33d12501548.png" /></p>
</blockquote>
<h2 id="配置启动脚本">配置启动脚本</h2>
<ul>
<li>
<p>vim /etc/systemd/system/nexus.service</p>
<div><pre class="hljs"><code>[Unit]
Description=nexus service
After=network.target

[Service]
Type=forking
LimitNOFILE=65536
ExecStart=/usr/<span class="hljs-built_in">local</span>/nexus/bin/nexus start
ExecStop=/usr/<span class="hljs-built_in">local</span>/nexus/bin/nexus stop
User=root
<span class="hljs-comment">#User=nexus</span>
Restart=on-abort

[Install]
WantedBy=multi-user.target</code></pre></div>
</li>
<li>
<p>重新加载daemon</p>
<ul>
<li><code>systemctl daemon-reload</code></li>
</ul>
</li>
</ul>
<h2 id="首次登录">首次登录</h2>
<ul>
<li>查看密码 <code>/usr/local/sonatype-work/nexus3/admin.password</code><br />
<img src="/_resources/1972240e8db94939ac7db5c72e1c8d0d.png" /></li>
<li>登录重置<br />
<img src="/_resources/dc405a5fd5d9490a9fa27c251c420315.png" /></li>
<li>确认访问方式 (默认为匿名登录，生产建议打开匿名访问功能,无需登录就可以下载资源)<br />
<img src="/_resources/e0594bfc6a30485ab8d18ee0a2a1141c.png" /></li>
<li>管理员界面<br />
<img src="/_resources/79e894f0d47b48589dbf0d00a99b6d45.png" /></li>
</ul>
<h2 id="自建apt仓库">自建apt仓库</h2>
<p><img src="/_resources/5fa0ae5854894619aa6713c1453708ea.png" /></p>
<p><img src="/_resources/979e517aa1c54887bc80cd87e482c5cc.png" /></p>
<p><img src="/_resources/b8aee9f49f294db8888b23adc0a420ef.png" /></p>
<p><img src="/_resources/bc9234dbfb554d6889189336eb7ebd08.png" /></p>
<div><pre class="hljs"><code>/etc/apt/sources.list

deb http://192.168.100.121:8081/repository/ubuntu-proxy/ focal main restricted universe multiverse</code></pre></div>
<p><img src="/_resources/795ed58d2e994c278c83138503f49999.png" /></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Hello world]]></title>
            <guid>20d5c160bdf84fc19cf99afb20c340dd</guid>
            <pubDate>Sat, 30 Mar 2024 13:51:36 GMT</pubDate>
            <content:encoded><![CDATA[<h1 id="hey">Hey</h1>
<p>This is the first post, testing everyting is ok.<br />
<img src="/_resources/dcfea66944514cff82a8e689c4cbe653.png" /></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Byte Byte Go 图]]></title>
            <guid>9ad6880a0e8c46039ae7c1a4c7adec23</guid>
            <pubDate>Sun, 21 Jan 2024 10:08:29 GMT</pubDate>
            <content:encoded><![CDATA[<h1 id="k8s-service-type">K8S service type</h1>
<p><img src="/_resources/ddb262f46b8840d28c216313e7b86daa.png" /></p>
<h1 id="rest-api-design">REST API Design</h1>
<p><img src="/_resources/ca5468c9a25d4ce68bc3f648dd55520f.jpeg" /></p>
<h1 id="top-6-log-parsing-commands">Top 6 log parsing commands</h1>
<p><img src="/_resources/e3e450a0738244f28d356846a0e9d94f.png" /></p>
<h1 id="8-popular-network-protocol">8 popular network protocol</h1>
<p><img src="/_resources/05ed2d25ba8c454fa2227bd553892c66.png" /></p>
<h1 id="sql-execution">SQL execution</h1>
<p><img src="/_resources/f8ee64388c7546b5a2c9afa31e140c3f.png" /></p>
<h1 id="jwt">JWT</h1>
<p><img src="/_resources/558c699e875a4ea8ad78d46df00a305d.png" /></p>
<h1 id="data-structure-power-your-database">data structure power your database</h1>
<p><img src="/_resources/9368ba6228594d29869970cf261b2721.png" /></p>
<h1 id="http-methods">HTTP methods</h1>
<p><img src="/_resources/2678b89f576f40f796c003cc9b976c9b.png" /></p>
<h1 id="linux-directory">Linux directory</h1>
<p><img src="/_resources/7e33fbe5a75f4dc08b4541f5fe7e4696.png" /></p>
<h1 id="when-you-type-url">When you type URL</h1>
<p><img src="/_resources/63a6fd8820a04e479980cf8e4a6d7c88.png" /></p>
<h1 id="forward-proxy-vs-rever-proxy">forward proxy vs rever proxy</h1>
<p><img src="/_resources/936a8886f0994dc288d25f21d0e223c8.png" /></p>
<h1 id="how-https-work">How https work</h1>
<p><img src="/_resources/a6401043babd4d19a5973cb7bbd822a2.png" /></p>
<h1 id="how-does-message-queue-evolve">How does message queue evolve</h1>
<p><img src="/_resources/a8e06fa592a3487d90904681ae5cf68e.png" /></p>
<h1 id="linux-network-tools">Linux network tools</h1>
<p><img src="/_resources/12143acf7a234feeab985017dad35cc7.png" /></p>
<h1 id="linux-boot-process">Linux boot process</h1>
<p><img src="/_resources/c3474e2c84aa48bcb91556e66623920c.png" /></p>
<h1 id="why-k8s">Why k8s</h1>
<p><img src="/_resources/69154c4b84a441be866266de73048132.png" /></p>
<h1 id="top-4-type-of-queus">Top 4 type of queus</h1>
<p><img src="/_resources/96f3ba31621c4090b170204ceaca437f.png" /></p>
<h1 id="defence-of-security-in-linux">Defence of security in linux</h1>
<p><img src="/_resources/bc24264ea2be4f4290a63fe69350725e.png" /></p>
<h1 id="security-search-engine">security search engine</h1>
<p><img src="/_resources/da03376cad4a4dfd827af7cd1eb7299a.png" /></p>
]]></content:encoded>
        </item>
    </channel>
</rss>